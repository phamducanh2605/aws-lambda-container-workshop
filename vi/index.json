[
{
	"uri": "//localhost:1313/vi/4-monitoring/4.1-deploy-test/",
	"title": "Deploy và Test Hiệu suất",
	"tags": [],
	"description": "",
	"content": "Deploy và Test Hiệu suất Tổng quan Trong phần này, chúng ta sẽ deploy Lambda functions và th ự c hi ệ n các b à i test hiệu suất để đ o l ườ ng hiệu suất c ủ a Container Images đã t ố i ư u h ó a.\nKiểm thử tải (Load Kiểm thử) Setup 1. Cài đặt Artillery cho Kiểm thử tải (Load Kiểm thử) 1 2 3 4 5 6 7 cd ~/lambda-container-workshop # Cài đặt Artillery npm install -g artillery # Kiểm tra version artillery version 2. Tạo load test configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 cat \u0026gt; tests/load-test-config.yml \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; config: target: \u0026#39;https://YOUR_API_ID.execute-api.us-east-1.amazonaws.com/prod\u0026#39; phases: - duration: 60 arrivalRate: 1 name: \u0026#34;Warm up\u0026#34; - duration: 120 arrivalRate: 5 name: \u0026#34;Ramp up load\u0026#34; - duration: 300 arrivalRate: 10 name: \u0026#34;Sustained load\u0026#34; defaults: headers: Nội dung-Type: \u0026#39;application/json\u0026#39; scenarios: - name: \u0026#34;Health Check\u0026#34; weight: 20 flow: - get: url: \u0026#34;/health\u0026#34; - name: \u0026#34;List Products\u0026#34; weight: 40 flow: - get: url: \u0026#34;/products\u0026#34; qs: limit: 10 - name: \u0026#34;Get Product\u0026#34; weight: 30 flow: - get: url: \u0026#34;/products/{{ $randomInt(1, 3) }}\u0026#34; - name: \u0026#34;Create Product\u0026#34; weight: 10 flow: - post: url: \u0026#34;/products\u0026#34; json: name: \u0026#34;Test Product {{ $randomInt(1, 1000) }}\u0026#34; price: \u0026#34;{{ $randomInt(10, 500) }}.99\u0026#34; category: \u0026#34;Test\u0026#34; description: \u0026#34;Load test product\u0026#34; EOF 3. Script chạy load test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 cat \u0026gt; scripts/run-load-test.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash FUNCTION_TYPE=${1:-\u0026#34;optimized\u0026#34;} TEST_DURATION=${2:-300} if [ \u0026#34;$FUNCTION_TYPE\u0026#34; != \u0026#34;optimized\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$FUNCTION_TYPE\u0026#34; != \u0026#34;base\u0026#34; ]; then echo \u0026#34;Usage: $0 [optimized|base] [duration_seconds]\u0026#34; echo \u0026#34;Example: $0 optimized 300\u0026#34; exit 1 fi echo \u0026#34;=== Running Load Test for $FUNCTION_TYPE function ===\u0026#34; # Get API endpoint based on function type if [ \u0026#34;$FUNCTION_TYPE\u0026#34; = \u0026#34;optimized\u0026#34; ]; then FUNCTION_NAME=\u0026#34;workshop-product-api-optimized\u0026#34; else FUNCTION_NAME=\u0026#34;workshop-product-api-base\u0026#34; fi # Get API Gateway ID (assuming it was created) API_ID=$(aws apigateway get-rest-apis \\ --query \u0026#34;items[?name==\u0026#39;workshop-product-api\u0026#39;].id\u0026#34; \\ --output text) if [ -z \u0026#34;$API_ID\u0026#34; ] || [ \u0026#34;$API_ID\u0026#34; = \u0026#34;None\u0026#34; ]; then echo \u0026#34;API Gateway not found. Creating one...\u0026#34; ./scripts/create-api-gateway.sh $FUNCTION_NAME API_ID=$(aws apigateway get-rest-apis \\ --query \u0026#34;items[?name==\u0026#39;workshop-product-api\u0026#39;].id\u0026#34; \\ --output text) fi API_ENDPOINT=\u0026#34;https://${API_ID}.execute-api.us-east-1.amazonaws.com/prod\u0026#34; echo \u0026#34;Kiểm thử endpoint: $API_ENDPOINT\u0026#34; # Update config file with actual endpoint sed \u0026#34;s|target: \u0026#39;https://YOUR_API_ID.execute-api.us-east-1.amazonaws.com/prod\u0026#39;|target: \u0026#39;$API_ENDPOINT\u0026#39;|\u0026#34; \\ tests/load-test-config.yml \u0026gt; tests/load-test-${FUNCTION_TYPE}.yml # Update test duration sed -i \u0026#34;s/duration: 300/duration: $TEST_DURATION/\u0026#34; tests/load-test-${FUNCTION_TYPE}.yml # Run load test echo \u0026#34;Starting load test...\u0026#34; artillery run tests/load-test-${FUNCTION_TYPE}.yml \\ --output tests/load-test-${FUNCTION_TYPE}-results.json # Generate HTML report artillery report tests/load-test-${FUNCTION_TYPE}-results.json \\ --output tests/load-test-${FUNCTION_TYPE}-report.html echo \u0026#34;✅ Load test completed!\u0026#34; echo \u0026#34;Results: tests/load-test-${FUNCTION_TYPE}-results.json\u0026#34; echo \u0026#34;Report: tests/load-test-${FUNCTION_TYPE}-report.html\u0026#34; EOF chmod +x scripts/run-load-test.sh Hiệu suất Đánh giá hiệu suất (Benchmarking) 1. Script benchmark cold starts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 cat \u0026gt; scripts/benchmark-cold-starts.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash FUNCTION_NAME=${1:-\u0026#34;workshop-product-api-optimized\u0026#34;} NUM_TESTS=${2:-10} echo \u0026#34;=== Cold Start Benchmark for $FUNCTION_NAME ===\u0026#34; echo \u0026#34;Number of tests: $NUM_TESTS\u0026#34; # Create results file RESULTS_FILE=\u0026#34;tests/cold-start-${FUNCTION_NAME}-$(date +%Y%m%d-%H%M%S).csv\u0026#34; echo \u0026#34;Test,Duration,InitDuration,BilledDuration,MemoryUsed,MaxMemoryUsed\u0026#34; \u0026gt; $RESULTS_FILE for i in $(seq 1 $NUM_TESTS); do echo \u0026#34;Test $i/$NUM_TESTS...\u0026#34; # Wait to ensure Cold Start sleep 30 # Invoke function and capture metrics RESPONSE=$(AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/health\u0026#34;}\u0026#39; \\ --log-type Tail \\ response.json 2\u0026gt;\u0026amp;1) # Extract duration from log DURATION=$(echo \u0026#34;$RESPONSE\u0026#34; | grep -o \u0026#39;\u0026#34;Duration\u0026#34;: [0-9.]*\u0026#39; | cut -d\u0026#39; \u0026#39; -f2) INIT_DURATION=$(echo \u0026#34;$RESPONSE\u0026#34; | grep -o \u0026#39;\u0026#34;Init Duration\u0026#34;: [0-9.]*\u0026#39; | cut -d\u0026#39; \u0026#39; -f3 || echo \u0026#34;0\u0026#34;) BILLED_DURATION=$(echo \u0026#34;$RESPONSE\u0026#34; | grep -o \u0026#39;\u0026#34;Billed Duration\u0026#34;: [0-9]*\u0026#39; | cut -d\u0026#39; \u0026#39; -f3) MEMORY_USED=$(echo \u0026#34;$RESPONSE\u0026#34; | grep -o \u0026#39;\u0026#34;Memory Used\u0026#34;: [0-9]*\u0026#39; | cut -d\u0026#39; \u0026#39; -f3) MAX_MEMORY=$(echo \u0026#34;$RESPONSE\u0026#34; | grep -o \u0026#39;\u0026#34;Max Memory Used\u0026#34;: [0-9]*\u0026#39; | cut -d\u0026#39; \u0026#39; -f4) # Save to CSV echo \u0026#34;$i,$DURATION,$INIT_DURATION,$BILLED_DURATION,$MEMORY_USED,$MAX_MEMORY\u0026#34; \u0026gt;\u0026gt; $RESULTS_FILE echo \u0026#34; Duration: ${DURATION}ms, Init: ${INIT_DURATION}ms, Memory: ${MEMORY_USED}MB\u0026#34; done # Calculate averages echo \u0026#34;=== Cold Start Results ===\u0026#34; echo \u0026#34;Results saved to: $RESULTS_FILE\u0026#34; # Calculate average Cold Start time AVG_DURATION=$(awk -F\u0026#39;,\u0026#39; \u0026#39;NR\u0026gt;1 {sum+=$2; count++} END {print sum/count}\u0026#39; $RESULTS_FILE) AVG_INIT=$(awk -F\u0026#39;,\u0026#39; \u0026#39;NR\u0026gt;1 {sum+=$3; count++} END {print sum/count}\u0026#39; $RESULTS_FILE) AVG_MEMORY=$(awk -F\u0026#39;,\u0026#39; \u0026#39;NR\u0026gt;1 {sum+=$5; count++} END {print sum/count}\u0026#39; $RESULTS_FILE) echo \u0026#34;Average Duration: ${AVG_DURATION}ms\u0026#34; echo \u0026#34;Average Init Duration: ${AVG_INIT}ms\u0026#34; echo \u0026#34;Average Memory Used: ${AVG_MEMORY}MB\u0026#34; # Dọn dẹp rm -f response.json EOF chmod +x scripts/benchmark-cold-starts.sh 2. Script so sánh hiệu suất 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 cat \u0026gt; scripts/compare-functions.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash echo \u0026#34;=== Comparing Function Hiệu suất ===\u0026#34; OPTIMIZED_FUNCTION=\u0026#34;workshop-product-api-optimized\u0026#34; BASE_FUNCTION=\u0026#34;workshop-product-api-base\u0026#34; # Test cold starts echo \u0026#34;1. Kiểm thử Cold Starts...\u0026#34; ./scripts/benchmark-cold-starts.sh $OPTIMIZED_FUNCTION 5 ./scripts/benchmark-cold-starts.sh $BASE_FUNCTION 5 # Test warm invocations echo \u0026#34;2. Kiểm thử Warm Invocations...\u0026#34; echo \u0026#34;Optimized Function (Warm):\u0026#34; for i in {1..5}; do time AWS Lambda invoke \\ --function-name $OPTIMIZED_FUNCTION \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;}\u0026#39; \\ /dev/null 2\u0026gt;\u0026amp;1 | grep real done echo \u0026#34;Base Function (Warm):\u0026#34; for i in {1..5}; do time AWS Lambda invoke \\ --function-name $BASE_FUNCTION \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;}\u0026#39; \\ /dev/null 2\u0026gt;\u0026amp;1 | grep real done # Get function sizes echo \u0026#34;3. Function Sizes:\u0026#34; AWS Lambda get-function \\ --function-name $OPTIMIZED_FUNCTION \\ --query \u0026#39;Configuration.CodeSize\u0026#39; \\ --output text | xargs -I {} echo \u0026#34;Optimized: {} bytes\u0026#34; AWS Lambda get-function \\ --function-name $BASE_FUNCTION \\ --query \u0026#39;Configuration.CodeSize\u0026#39; \\ --output text | xargs -I {} echo \u0026#34;Base: {} bytes\u0026#34; echo \u0026#34;✅ Hiệu suất comparison completed!\u0026#34; EOF chmod +x scripts/compare-functions.sh CloudWatch Metrics Analysis 1. Script tạo custom metrics 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 cat \u0026gt; scripts/analyze-metrics.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash FUNCTION_NAME=${1:-\u0026#34;workshop-product-api-optimized\u0026#34;} START_TIME=${2:-$(date -d \u0026#39;1 hour ago\u0026#39; --iso-8601)} END_TIME=${3:-$(date --iso-8601)} echo \u0026#34;=== Analyzing CloudWatch Metrics ===\u0026#34; echo \u0026#34;Function: $FUNCTION_NAME\u0026#34; echo \u0026#34;Time Range: $START_TIME to $END_TIME\u0026#34; # Get Duration metrics echo \u0026#34;1. Duration Metrics:\u0026#34; aws CloudWatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Duration \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --start-time $START_TIME \\ --end-time $END_TIME \\ --period 300 \\ --statistics Average,Maximum,Minimum \\ --query \u0026#39;Datapoints[*].[Timestamp,Average,Maximum,Minimum]\u0026#39; \\ --output table # Get Invocation metrics echo \u0026#34;2. Invocation Metrics:\u0026#34; aws CloudWatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Invocations \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --start-time $START_TIME \\ --end-time $END_TIME \\ --period 300 \\ --statistics Sum \\ --query \u0026#39;Datapoints[*].[Timestamp,Sum]\u0026#39; \\ --output table # Get Error metrics echo \u0026#34;3. Error Metrics:\u0026#34; aws CloudWatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Errors \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --start-time $START_TIME \\ --end-time $END_TIME \\ --period 300 \\ --statistics Sum \\ --query \u0026#39;Datapoints[*].[Timestamp,Sum]\u0026#39; \\ --output table # Get Throttle metrics echo \u0026#34;4. Throttle Metrics:\u0026#34; aws CloudWatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Throttles \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --start-time $START_TIME \\ --end-time $END_TIME \\ --period 300 \\ --statistics Sum \\ --query \u0026#39;Datapoints[*].[Timestamp,Sum]\u0026#39; \\ --output table echo \u0026#34;✅ Metrics analysis completed!\u0026#34; EOF chmod +x scripts/analyze-metrics.sh Chạy Hiệu suất Tests 1. Test cold starts 1 2 3 4 5 # Test optimized function ./scripts/benchmark-cold-starts.sh workshop-product-api-optimized 10 # Test base function ./scripts/benchmark-cold-starts.sh workshop-product-api-base 10 2. So sánh hiệu suất 1 ./scripts/compare-functions.sh 3. Chạy load test 1 2 3 4 5 # Load test optimized function ./scripts/run-load-test.sh optimized 300 # Load test base function ./scripts/run-load-test.sh base 300 4. Phân tích metrics 1 2 3 4 # Analyze metrics for last hour ./scripts/analyze-metrics.sh workshop-product-api-optimized ./scripts/analyze-metrics.sh workshop-product-api-base Hiệu suất Report 1. Tạo hiệu suất report 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 cat \u0026gt; scripts/generate-report.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash echo \u0026#34;=== Lambda Container Hiệu suất Report ===\u0026#34; echo \u0026#34;Generated: $(date)\u0026#34; echo # Function information echo \u0026#34;## Function Information\u0026#34; echo \u0026#34;| Function | Package Type | Memory | Timeout | Code Size |\u0026#34; echo \u0026#34;|----------|--------------|--------|---------|-----------|\u0026#34; for func in workshop-product-api-optimized workshop-product-api-base; do INFO=$(AWS Lambda get-function --function-name $func --query \u0026#39;Configuration.[FunctionName,PackageType,MemorySize,Timeout,CodeSize]\u0026#39; --output text) echo \u0026#34;| $INFO |\u0026#34; | tr \u0026#39;\\t\u0026#39; \u0026#39;|\u0026#39; done echo # Cold Start analysis echo \u0026#34;## Cold Start Hiệu suất\u0026#34; if [ -f \u0026#34;tests/cold-start-workshop-product-api-optimized-*.csv\u0026#34; ]; then OPTIMIZED_FILE=$(ls tests/cold-start-workshop-product-api-optimized-*.csv | tail -1) OPT_AVG=$(awk -F\u0026#39;,\u0026#39; \u0026#39;NR\u0026gt;1 {sum+=$2; count++} END {print sum/count}\u0026#39; $OPTIMIZED_FILE) echo \u0026#34;Optimized Average Cold Start: ${OPT_AVG}ms\u0026#34; fi if [ -f \u0026#34;tests/cold-start-workshop-product-api-base-*.csv\u0026#34; ]; then BASE_FILE=$(ls tests/cold-start-workshop-product-api-base-*.csv | tail -1) BASE_AVG=$(awk -F\u0026#39;,\u0026#39; \u0026#39;NR\u0026gt;1 {sum+=$2; count++} END {print sum/count}\u0026#39; $BASE_FILE) echo \u0026#34;Base Average Cold Start: ${BASE_AVG}ms\u0026#34; fi echo # Load test results echo \u0026#34;## Load Test Results\u0026#34; if [ -f \u0026#34;tests/load-test-optimized-results.json\u0026#34; ]; then echo \u0026#34;Optimized Function Load Test:\u0026#34; node -e \u0026#34; const fs = require(\u0026#39;fs\u0026#39;); const data = JSON.parse(fs.readFileSync(\u0026#39;tests/load-test-optimized-results.json\u0026#39;)); console.log(\u0026#39;- Total Requests:\u0026#39;, data.aggregate.counters[\u0026#39;http.requests\u0026#39;]); console.log(\u0026#39;- Success Rate:\u0026#39;, (100 - (data.aggregate.counters[\u0026#39;http.request_rate\u0026#39;] || 0)).toFixed(2) + \u0026#39;%\u0026#39;); console.log(\u0026#39;- Average Response Time:\u0026#39;, data.aggregate.latency.mean.toFixed(2) + \u0026#39;ms\u0026#39;); console.log(\u0026#39;- 95th Percentile:\u0026#39;, data.aggregate.latency.p95.toFixed(2) + \u0026#39;ms\u0026#39;); \u0026#34; fi echo \u0026#34;✅ Hiệu suất report generated!\u0026#34; EOF chmod +x scripts/generate-report.sh 1 2 # Generate hiệu suất report ./scripts/generate-report.sh Kết luận Bạn đã ho à n th à nh:\n✅ Setup Kiểm thử t ả i (Load Kiểm thử) với Artillery ✅ Benchmark Cold Start hiệu suất ✅ So s á nh hiệu suất gi ữ a optimized và base functions ✅ Ph â n t í ch CloudWatch metrics ✅ Tạo hiệu suất reports Expected Results:\nOptimized Container Images th ườ ng c ó Cold Start nhanh h ơ n 20-40% Image size nh ỏ h ơ n 30-50% Memory usage t ố i ư u h ơ n Response time cải thiện trong sustained load Tiếp theo, chúng ta sẽ t ì m hi ể u v ề các chiến lược bộ nhớ đệm (Bộ nhớ đệm) và Khởi độ ng tr ướ c (Warm-up) để cải thiện hiệu suất h ơ n n ữ a.\n"
},
{
	"uri": "//localhost:1313/vi/1-introduce/",
	"title": "Giới thiệu &amp; Kiến trúc",
	"tags": [],
	"description": "",
	"content": "Giới thiệu \u0026amp; Kiến trúc Tổng quan Workshop Chào mừng bạn đến với workshop Tối ưu hóa hiệu suất AWS Lambda Container Images! Trong phiên thực hành này, bạn sẽ học các kỹ thuật tiên tiến để tối ưu hóa Lambda functions sử dụng Container Images, đạt được Cold Start dưới 1 giây và tối ưu hóa việc sử dụng tài nguyên.\nNhững gì bạn sẽ học Tối ưu hóa Container Image: Xây dựng Container Images hiệu quả, nhẹ Giảm Cold Start: Đạt được thời gian Cold Start \u0026lt;1s thông qua các kỹ thuật đã được chứng minh Tối ưu hóa Memory: Profile và tối ưu hóa các pattern sử dụng memory Chiến lược Caching: Triển khai caching đa tầng cho hiệu suất Monitoring \u0026amp; Observability: Thiết lập monitoring hiệu suất toàn diện Tối ưu hóa Chi phí: Giảm chi phí vận hành thông qua việc sử dụng tài nguyên hiệu quả Tổng quan Kiến trúc Mục tiêu Hiệu suất Chính Khi kết thúc workshop này, bạn sẽ đạt được:\nMetric Trạng thái Hiện tại Trạng thái Mục tiêu Cải thiện Thời gian Cold Start 3-5 giây \u0026lt;1 giây 70-80% Hiệu quả Memory 40-60% 80-90% 50% Thời gian Response 1.5-2s \u0026lt;500ms 70% Tỷ lệ Lỗi 2-3% \u0026lt;0.5% 80% Chi phí Baseline -45% Tiết kiệm 45% Kịch bản Workshop Bạn sẽ làm việc với một ứng dụng e-commerce mẫu bao gồm:\nProduct Catalog API: Duyệt và tìm kiếm sản phẩm Order Processing API: Xử lý tạo và cập nhật đơn hàng User Management API: Xác thực và hồ sơ người dùng Recommendation Engine: Gợi ý sản phẩm dựa trên ML Mỗi API sẽ được containerized và tối ưu hóa để đạt hiệu suất tối đa.\nKiểm tra Yêu cầu Trước khi tiếp tục, đảm bảo bạn có:\n✅ AWS Account với quyền phù hợp ✅ AWS CLI đã được cấu hình ✅ Docker đã cài đặt và chạy ✅ Kiến thức cơ bản về Lambda và containers ✅ Môi trường phát triển Python 3.11+ Kết quả Mong đợi Sau khi hoàn thành workshop này:\nKỹ năng Kỹ thuật: Thành thạo các kỹ thuật tối ưu hóa container Chuyên môn Hiệu suất: Hiểu về tối ưu hóa Cold Start Thành thạo Monitoring: Triển khai observability toàn diện Tối ưu hóa Chi phí: Giảm chi phí vận hành Sẵn sàng Production: Triển khai các giải pháp tối ưu một cách tự tin Tiếp theo: Yêu cầu \u0026amp; Thiết lập môi trường\n"
},
{
	"uri": "//localhost:1313/vi/7-production/7.1-cicd-pipeline/",
	"title": "Quy trình CI/CD (CI/CD Pipeline) Setup",
	"tags": [],
	"description": "",
	"content": "Quy trình CI/CD (CI/CD Pipeline) Setup Tổng quan Trong phần này, chúng ta sẽ thiết lập Quy trình CI/CD (CI/CD Pipeline) để t ự độ ng build, test và deploy Lambda Container Images s ử dụng GitHub Actions.\nGitHub Repository Setup 1. Tạo GitHub Repository 1 2 3 4 5 6 7 8 9 cd ~/lambda-container-workshop # Initialize git repository git init git add . git commit -m \u0026#34;Initial commit: Lambda container workshop\u0026#34; # Create .github/workflows directory mkdir -p .github/workflows 2. GitHub Secrets Configuration C ầ n th ê m các secrets sau và o GitHub repository:\n1 2 3 4 5 6 7 8 9 10 11 12 13 # AWS credentials AWS_ACCESS_KEY_ID=your_access_key AWS_SECRET_ACCESS_KEY=your_secret_key AWS_REGION=us-east-1 AWS_ACCOUNT_ID=123456789012 # ECR repository ECR_REGISTRY=123456789012.dkr.ecr.us-east-1.amazonaws.com ECR_REPOSITORY=lambda-workshop/product-api # Lambda function names LAMBDA_FUNCTION_STAGING=workshop-product-api-staging LAMBDA_FUNCTION_PRODUCTION=workshop-product-api-Môi trường sản xuất Quy trình CI/CD (CI/CD Pipeline) Configuration 1. Main CI/CD Workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 cat \u0026gt; .github/workflows/deploy.yml \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; name: Deploy Lambda Container on: push: branches: [ main, develop ] pull_request: branches: [ main ] env: AWS_REGION: ${{ secrets.AWS_REGION }} ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }} ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }} jobs: test: name: Run Tests runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v4 with: python-version: \u0026#39;3.11\u0026#39; - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt pip install pytest pytest-cov flake8 black - name: Run linting run: | flake8 src/ lambda_function.py --max-line-length=100 black --check src/ lambda_function.py - name: Run unit tests run: | python -m pytest tests/ -v --cov=src --cov-report=xml - name: Upload coverage to Codecov uses: codecov/codecov-action@v3 with: file: ./coverage.xml Bảo mật-scan: name: Bảo mật Scan runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Run Trivy vulnerability scanner uses: aquasecurity/trivy-action@master with: scan-type: \u0026#39;fs\u0026#39; scan-ref: \u0026#39;.\u0026#39; format: \u0026#39;sarif\u0026#39; output: \u0026#39;trivy-results.sarif\u0026#39; - name: Upload Trivy scan results to GitHub Bảo mật tab uses: github/codeql-action/upload-sarif@v2 with: sarif_file: \u0026#39;trivy-results.sarif\u0026#39; build-and-push: name: Build and Push Container runs-on: ubuntu-latest needs: [test, Bảo mật-scan] if: github.event_name == \u0026#39;push\u0026#39; outputs: image-tag: ${{ steps.build.outputs.image-tag }} steps: - name: Checkout code uses: actions/checkout@v4 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v4 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Login to Amazon ECR id: login-ecr uses: aws-actions/amazon-ecr-login@v2 - name: Build and push Docker image id: build run: | # Generate image tag IMAGE_TAG=${GITHUB_SHA::8} if [ \u0026#34;${{ github.ref }}\u0026#34; = \u0026#34;refs/heads/main\u0026#34; ]; then IMAGE_TAG=\u0026#34;prod-${IMAGE_TAG}\u0026#34; else IMAGE_TAG=\u0026#34;staging-${IMAGE_TAG}\u0026#34; fi # Build image docker build \\ -f docker/optimized/Dockerfile \\ -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \\ -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \\ . # Push image docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest echo \u0026#34;image-tag=$IMAGE_TAG\u0026#34; \u0026gt;\u0026gt; $GITHUB_OUTPUT echo \u0026#34;Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\u0026#34; deploy-staging: name: Deploy to Staging runs-on: ubuntu-latest needs: build-and-push if: github.ref == \u0026#39;refs/heads/develop\u0026#39; environment: staging steps: - name: Checkout code uses: actions/checkout@v4 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v4 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Deploy to Lambda run: | IMAGE_URI=\u0026#34;${ECR_REGISTRY}/${ECR_REPOSITORY}:${{ needs.build-and-push.outputs.image-tag }}\u0026#34; # Update Lambda function AWS Lambda update-function-code \\ --function-name ${{ secrets.LAMBDA_FUNCTION_STAGING }} \\ --image-uri $IMAGE_URI # Wait for update to complete AWS Lambda wait function-updated \\ --function-name ${{ secrets.LAMBDA_FUNCTION_STAGING }} - name: Run smoke tests run: | # Test health endpoint AWS Lambda invoke \\ --function-name ${{ secrets.LAMBDA_FUNCTION_STAGING }} \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/health\u0026#34;}\u0026#39; \\ response.json # Check response if grep -q \u0026#39;\u0026#34;statusCode\u0026#34;: 200\u0026#39; response.json; then echo \u0026#34;✅ Smoke test passed\u0026#34; else echo \u0026#34;❌ Smoke test failed\u0026#34; cat response.json exit 1 fi deploy-Môi trường sản xuất: name: Deploy to Môi trường sản xuất runs-on: ubuntu-latest needs: build-and-push if: github.ref == \u0026#39;refs/heads/main\u0026#39; environment: Môi trường sản xuất steps: - name: Checkout code uses: actions/checkout@v4 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v4 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Blue-Green Triển khai run: | IMAGE_URI=\u0026#34;${ECR_REGISTRY}/${ECR_REPOSITORY}:${{ needs.build-and-push.outputs.image-tag }}\u0026#34; FUNCTION_NAME=\u0026#34;${{ secrets.LAMBDA_FUNCTION_PRODUCTION }}\u0026#34; # Update function code NEW_VERSION=$(AWS Lambda update-function-code \\ --function-name $FUNCTION_NAME \\ --image-uri $IMAGE_URI \\ --query \u0026#39;Version\u0026#39; --output text) echo \u0026#34;New version: $NEW_VERSION\u0026#34; # Wait for update AWS Lambda wait function-updated --function-name $FUNCTION_NAME # Run comprehensive tests ./scripts/test-lambda.sh $FUNCTION_NAME # Gradual traffic shift (10% initially) AWS Lambda update-alias \\ --function-name $FUNCTION_NAME \\ --name PROD \\ --routing-config \u0026#34;AdditionalVersionWeights={\\\u0026#34;$NEW_VERSION\\\u0026#34;:0.1}\u0026#34; || \\ AWS Lambda create-alias \\ --function-name $FUNCTION_NAME \\ --name PROD \\ --function-version $NEW_VERSION echo \u0026#34;✅ Deployed to Môi trường sản xuất with 10% traffic\u0026#34; - name: Monitor and Complete Triển khai run: | FUNCTION_NAME=\u0026#34;${{ secrets.LAMBDA_FUNCTION_PRODUCTION }}\u0026#34; # Wait 5 minutes for monitoring echo \u0026#34;monitoring Triển khai for 5 minutes...\u0026#34; sleep 300 # Check error rate ERROR_COUNT=$(aws CloudWatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Errors \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --start-time $(date -u -d \u0026#39;10 minutes ago\u0026#39; +%Y-%m-%dT%H:%M:%S) \\ --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \\ --period 300 \\ --statistics Sum \\ --query \u0026#39;Datapoints[0].Sum\u0026#39; --output text) if [ \u0026#34;$ERROR_COUNT\u0026#34; = \u0026#34;None\u0026#34; ] || [ \u0026#34;$ERROR_COUNT\u0026#34; -lt 5 ]; then # Complete triển khai (100% traffic) AWS Lambda update-alias \\ --function-name $FUNCTION_NAME \\ --name PROD \\ --function-version ${{ needs.build-and-push.outputs.image-tag }} \\ --routing-config \u0026#39;{}\u0026#39; echo \u0026#34;✅ Triển khai completed successfully\u0026#34; else # Rollback AWS Lambda update-alias \\ --function-name $FUNCTION_NAME \\ --name PROD \\ --routing-config \u0026#39;{}\u0026#39; echo \u0026#34;❌ Triển khai rolled back due to errors\u0026#34; exit 1 fi hiệu suất-test: name: Hiệu suất Test runs-on: ubuntu-latest needs: deploy-Môi trường sản xuất if: github.ref == \u0026#39;refs/heads/main\u0026#39; steps: - name: Checkout code uses: actions/checkout@v4 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v4 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ env.AWS_REGION }} - name: Install Artillery run: npm install -g artillery - name: Run hiệu suất tests run: | # Get API Gateway endpoint API_ID=$(aws apigateway get-rest-apis \\ --query \u0026#34;items[?name==\u0026#39;workshop-product-api\u0026#39;].id\u0026#34; \\ --output text) if [ \u0026#34;$API_ID\u0026#34; != \u0026#34;None\u0026#34; ]; then API_ENDPOINT=\u0026#34;https://${API_ID}.execute-api.us-east-1.amazonaws.com/prod\u0026#34; # Update test config sed \u0026#34;s|YOUR_API_ID|$API_ID|\u0026#34; tests/load-test-config.yml \u0026gt; tests/load-test-prod.yml # Run load test artillery run tests/load-test-prod.yml --output perf-results.json # Generate report artillery report perf-results.json --output perf-report.html fi - name: Upload hiệu suất results uses: actions/upload-artifact@v3 with: name: hiệu suất-results path: | perf-results.json perf-report.html EOF 2. Pull Request Workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 cat \u0026gt; .github/workflows/pr-check.yml \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; name: Pull Request Checks on: pull_request: branches: [ main, develop ] jobs: code-quality: name: Code Quality Checks runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Set up Python uses: actions/setup-python@v4 with: python-version: \u0026#39;3.11\u0026#39; - name: Install dependencies run: | python -m pip install --upgrade pip pip install -r requirements.txt pip install pytest flake8 black bandit safety - name: Code formatting check run: black --check --diff src/ lambda_function.py - name: Linting run: flake8 src/ lambda_function.py --max-line-length=100 - name: Bảo mật check run: | bandit -r src/ lambda_function.py safety check - name: Run tests run: python -m pytest tests/ -v - name: Container build test run: | docker build -f docker/optimized/Dockerfile -t test-image . echo \u0026#34;✅ Container builds successfully\u0026#34; size-check: name: Container Size Check runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Build and check size run: | docker build -f docker/optimized/Dockerfile -t size-check . SIZE=$(docker images size-check --format \u0026#34;{{.Size}}\u0026#34;) echo \u0026#34;Container size: $SIZE\u0026#34; # Check if size is reasonable (\u0026lt; 500MB) SIZE_BYTES=$(docker inspect size-check --format=\u0026#39;{{.Size}}\u0026#39;) if [ $SIZE_BYTES -gt 524288000 ]; then echo \u0026#34;❌ Container size too large: $SIZE\u0026#34; exit 1 else echo \u0026#34;✅ Container size acceptable: $SIZE\u0026#34; fi EOF 3. Release Workflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 cat \u0026gt; .github/workflows/release.yml \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; name: Release on: release: types: [published] jobs: deploy-release: name: Deploy Release runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Configure AWS credentials uses: aws-actions/configure-aws-credentials@v4 with: aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} aws-region: ${{ secrets.AWS_REGION }} - name: Login to Amazon ECR uses: aws-actions/amazon-ecr-login@v2 - name: Build and push release image run: | RELEASE_TAG=${{ github.event.release.tag_name }} docker build \\ -f docker/optimized/Dockerfile \\ -t ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:$RELEASE_TAG \\ -t ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:stable \\ . docker push ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:$RELEASE_TAG docker push ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:stable - name: Update Môi trường sản xuất Lambda run: | IMAGE_URI=\u0026#34;${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}:${{ github.event.release.tag_name }}\u0026#34; AWS Lambda update-function-code \\ --function-name ${{ secrets.LAMBDA_FUNCTION_PRODUCTION }} \\ --image-uri $IMAGE_URI echo \u0026#34;✅ Môi trường sản xuất updated to release ${{ github.event.release.tag_name }}\u0026#34; EOF Local Development Scripts 1. Pre-commit hooks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cat \u0026gt; .pre-commit-config.yaml \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; repos: - repo: https://github.com/psf/black rev: 23.0.0 hooks: - id: black language_version: python3.11 - repo: https://github.com/pycqa/flake8 rev: 6.0.0 hooks: - id: flake8 args: [--max-line-length=100] - repo: https://github.com/PyCQA/bandit rev: 1.7.5 hooks: - id: bandit args: [-r, src/, lambda_function.py] - repo: https://github.com/pre-commit/pre-commit-hooks rev: v4.4.0 hooks: - id: trailing-whitespace - id: end-of-file-fixer - id: check-yaml - id: check-added-large-files EOF # Install pre-commit pip install pre-commit pre-commit install 2. Local CI script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 cat \u0026gt; scripts/local-ci.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash echo \u0026#34;=== Running Local CI Checks ===\u0026#34; # Code formatting echo \u0026#34;1. Checking code formatting...\u0026#34; black --check src/ lambda_function.py if [ $? -ne 0 ]; then echo \u0026#34;❌ Code formatting failed. Run: black src/ lambda_function.py\u0026#34; exit 1 fi # Linting echo \u0026#34;2. Running linting...\u0026#34; flake8 src/ lambda_function.py --max-line-length=100 if [ $? -ne 0 ]; then echo \u0026#34;❌ Linting failed\u0026#34; exit 1 fi # Bảo mật check echo \u0026#34;3. Running Bảo mật checks...\u0026#34; bandit -r src/ lambda_function.py if [ $? -ne 0 ]; then echo \u0026#34;❌ Bảo mật check failed\u0026#34; exit 1 fi # Unit tests echo \u0026#34;4. Running unit tests...\u0026#34; python -m pytest tests/ -v if [ $? -ne 0 ]; then echo \u0026#34;❌ Unit tests failed\u0026#34; exit 1 fi # Container build test echo \u0026#34;5. Kiểm thử container build...\u0026#34; docker build -f docker/optimized/Dockerfile -t local-test . if [ $? -ne 0 ]; then echo \u0026#34;❌ Container build failed\u0026#34; exit 1 fi echo \u0026#34;✅ All local CI checks passed!\u0026#34; EOF chmod +x scripts/local-ci.sh monitoring và Alerting 1. Triển khai monitoring 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 cat \u0026gt; scripts/monitor-Triển khai.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash FUNCTION_NAME=${1:-\u0026#34;workshop-product-api-Môi trường sản xuất\u0026#34;} DURATION=${2:-300} # 5 minutes echo \u0026#34;=== monitoring Triển khai for $FUNCTION_NAME ===\u0026#34; START_TIME=$(date -u -d \u0026#39;1 minute ago\u0026#39; +%Y-%m-%dT%H:%M:%S) END_TIME=$(date -u +%Y-%m-%dT%H:%M:%S) # Monitor for specified duration for i in $(seq 1 $((DURATION/60))); do echo \u0026#34;Minute $i/$((DURATION/60))...\u0026#34; # Check error rate ERRORS=$(aws CloudWatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Errors \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --start-time $START_TIME \\ --end-time $END_TIME \\ --period 60 \\ --statistics Sum \\ --query \u0026#39;Datapoints[0].Sum\u0026#39; --output text) # Check duration DURATION_MS=$(aws CloudWatch get-metric-statistics \\ --namespace AWS/Lambda \\ --metric-name Duration \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --start-time $START_TIME \\ --end-time $END_TIME \\ --period 60 \\ --statistics Average \\ --query \u0026#39;Datapoints[0].Average\u0026#39; --output text) echo \u0026#34; Errors: ${ERRORS:-0}, Avg Duration: ${DURATION_MS:-0}ms\u0026#34; # Alert if too many errors if [ \u0026#34;${ERRORS:-0}\u0026#34; -gt 5 ]; then echo \u0026#34;❌ High error rate detected!\u0026#34; exit 1 fi sleep 60 done echo \u0026#34;✅ Triển khai monitoring completed successfully\u0026#34; EOF chmod +x scripts/monitor-Triển khai.sh Documentation 1. CI/CD README 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 cat \u0026gt; CI-CD-README.md \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Quy trình CI/CD (CI/CD Pipeline) Documentation ## Pipeline Overview This repository uses GitHub Actions for automated CI/CD Pipeline with the following stages: ## Workflows ### 1. Main Triển khai (`deploy.yml`) - **Trigger**: Push to `main` or `develop` branches - **Stages**: - Test: Unit tests, linting, Bảo mật scan - Build: Container image build and push to ECR - Deploy: Blue-green Triển khai to Lambda - Monitor: Hiệu suất Kiểm thử and monitoring ### 2. Pull Request Checks (`pr-check.yml`) - **Trigger**: Pull requests to `main` or `develop` - **Checks**: Code quality, Bảo mật, container build test ### 3. Release Triển khai (`release.yml`) - **Trigger**: GitHub release creation - **Action**: Deploy stable release to Môi trường sản xuất ## Environments ### Staging - **Branch**: `develop` - **Function**: `workshop-product-api-staging` - **Purpose**: Integration Kiểm thử ### Môi trường sản xuất - **Branch**: `main` - **Function**: `workshop-product-api-Môi trường sản xuất` - **Strategy**: Blue-green Triển khai with gradual traffic shift ## Required Secrets ```bash AWS_ACCESS_KEY_ID=your_access_key AWS_SECRET_ACCESS_KEY=your_secret_key AWS_REGION=us-east-1 AWS_ACCOUNT_ID=123456789012 ECR_REGISTRY=123456789012. dkr. ecr. us-east-1. amazonaws. com ECR_REPOSITORY=lambda-workshop/product-api LAMBDA_FUNCTION_STAGING=workshop-product-api-staging LAMBDA_FUNCTION_PRODUCTION=workshop-product-api-M ô i tr ườ ng sản xuất Local Development 1 2 3 4 5 6 7 8 # Run local CI checks ./scripts/local-ci. sh # Install pre-commit hooks pre-commit install # Manual Triển khai ./scripts/deploy-manual. sh M ô i tr ườ ng sản xuất monitoring CloudWatch metrics for error rates and hiệu suất Automated rollback on high error rates Hiệu suất Kiểm thử after each Triển khai Slack/email notifications (configure SNS) Troubleshooting Common Issues Build failures: Check Docker syntax and dependencies Test failures: Run tests locally first Triển khai failures: Check IAM permissions and Lambda limits Hiệu suất issues: Review container optimization Rollback Procedure 1 2 3 4 5 # Manual rollback AWS Lambda update-alias \\ --function-name workshop-product-api-M ô i tr ườ ng sản xuất \\ --name PROD \\ --function-version PREVIOUS_VERSION EOF\n## Kết luận Bạn đã thiết lập th à nh c ô ng: - ✅ Complete Quy trình CI/CD (CI/CD Pipeline) với GitHub Actions - ✅ Multi-environment triển khai (staging/M ô i tr ườ ng sản xuất) - ✅ Blue-green Tri ể n khai strategy - ✅ Automated Kiểm thử và Bảo mật scanning - ✅ Hi ệ u su ấ t giám sát (Monitoring) và alerting - ✅ Rollback procedures - ✅ Local development tools Thực hành tốt nhất Implemented:\nAutomated Kiểm thử at every stage Bảo mật scanning before Tri ể n khai Gradual traffic shifting for M ô i tr ườ ng sản xuất Comprehensive giám sát (Monitoring) and alerting Easy rollback procedures Pipeline này đả m b ả o deployments an to à n và reliable cho Lambda container applications. "
},
{
	"uri": "//localhost:1313/vi/3-container-optimization/3.1-create-sample-app/",
	"title": "Tạo ứng dụng mẫu",
	"tags": [],
	"description": "",
	"content": "Tạo ứng dụng mẫu Tổng quan Trong phần này, chúng ta sẽ tạo một ứng dụng API mẫu để demo các k ỹ thuật t ố i ư u h ó a Lambda Container Images.\nTạo Lambda Function Code 1. Tạo main Lambda handler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 cd ~/lambda-container-workshop # Tạo file lambda_function.py cat \u0026gt; lambda_function.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import json import os import time import boto3 from datetime import datetime from src.api.product_service import ProductService from src.monitoring.performance_metrics import PerformanceMetrics # Khởi tạo connections bên ngoài handler để tái sử dụng product_service = ProductService() metrics = PerformanceMetrics() def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34; Main Lambda handler cho Product API \u0026#34;\u0026#34;\u0026#34; start_time = time.time() try: # Log request info print(f\u0026#34;Request: {json.dumps(event)}\u0026#34;) # Parse request http_method = event.get(\u0026#39;httpMethod\u0026#39;, \u0026#39;GET\u0026#39;) path = event.get(\u0026#39;path\u0026#39;, \u0026#39;/\u0026#39;) body = json.loads(event.get(\u0026#39;body\u0026#39;, \u0026#39;{}\u0026#39;)) if event.get(\u0026#39;body\u0026#39;) else {} path_parameters = event.get(\u0026#39;pathParameters\u0026#39;) or {} query_parameters = event.get(\u0026#39;queryStringParameters\u0026#39;) or {} # Route requests if path == \u0026#39;/health\u0026#39;: response = handle_health_check() elif path.startswith(\u0026#39;/products\u0026#39;): response = handle_products(http_method, path, body, path_parameters, query_parameters) else: response = { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Not Found\u0026#39;}) } # Add CORS headers response[\u0026#39;headers\u0026#39;] = { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;, \u0026#39;Access-Control-Allow-Methods\u0026#39;: \u0026#39;GET, POST, PUT, DELETE, OPTIONS\u0026#39;, \u0026#39;Access-Control-Allow-Headers\u0026#39;: \u0026#39;Content-Type, Authorization\u0026#39; } # Record metrics duration = (time.time() - start_time) * 1000 metrics.record_request(http_method, path, response[\u0026#39;statusCode\u0026#39;], duration) return response except Exception as e: print(f\u0026#34;Error: {str(e)}\u0026#34;) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;headers\u0026#39;: {\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;}, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Internal Server Error\u0026#39;}) } def handle_health_check(): \u0026#34;\u0026#34;\u0026#34;Health check endpoint\u0026#34;\u0026#34;\u0026#34; return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;status\u0026#39;: \u0026#39;healthy\u0026#39;, \u0026#39;timestamp\u0026#39;: datetime.utcnow().isoformat(), \u0026#39;version\u0026#39;: \u0026#39;1.0.0\u0026#39; }) } def handle_products(method, path, body, path_params, query_params): \u0026#34;\u0026#34;\u0026#34;Handle product-related requests\u0026#34;\u0026#34;\u0026#34; if method == \u0026#39;GET\u0026#39;: if path == \u0026#39;/products\u0026#39;: # List products limit = int(query_params.get(\u0026#39;limit\u0026#39;, 10)) offset = int(query_params.get(\u0026#39;offset\u0026#39;, 0)) products = product_service.list_products(limit, offset) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(products) } elif path_params.get(\u0026#39;id\u0026#39;): # Get single product product_id = path_params[\u0026#39;id\u0026#39;] product = product_service.get_product(product_id) if product: return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(product) } else: return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Product not found\u0026#39;}) } elif method == \u0026#39;POST\u0026#39; and path == \u0026#39;/products\u0026#39;: # Create product product = product_service.create_product(body) return { \u0026#39;statusCode\u0026#39;: 201, \u0026#39;body\u0026#39;: json.dumps(product) } elif method == \u0026#39;PUT\u0026#39; and path_params.get(\u0026#39;id\u0026#39;): # Update product product_id = path_params[\u0026#39;id\u0026#39;] product = product_service.update_product(product_id, body) if product: return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(product) } else: return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Product not found\u0026#39;}) } elif method == \u0026#39;DELETE\u0026#39; and path_params.get(\u0026#39;id\u0026#39;): # Delete product product_id = path_params[\u0026#39;id\u0026#39;] success = product_service.delete_product(product_id) if success: return { \u0026#39;statusCode\u0026#39;: 204, \u0026#39;body\u0026#39;: \u0026#39;\u0026#39; } else: return { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Product not found\u0026#39;}) } return { \u0026#39;statusCode\u0026#39;: 405, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Method not allowed\u0026#39;}) } EOF 2. Tạo Product Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 cat \u0026gt; src/api/product_service.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import boto3 import json import uuid from datetime import datetime from typing import List, Dict, Optional class ProductService: def __init__(self): # Sử dụng DynamoDB local hoặc mock data cho demo self.products = [ { \u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Laptop Dell XPS 13\u0026#39;, \u0026#39;price\u0026#39;: 1299.99, \u0026#39;category\u0026#39;: \u0026#39;Electronics\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;High-performance ultrabook\u0026#39;, \u0026#39;created_at\u0026#39;: \u0026#39;2025-01-01T00:00:00Z\u0026#39; }, { \u0026#39;id\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;iPhone 15 Pro\u0026#39;, \u0026#39;price\u0026#39;: 999.99, \u0026#39;category\u0026#39;: \u0026#39;Electronics\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Latest iPhone model\u0026#39;, \u0026#39;created_at\u0026#39;: \u0026#39;2025-01-01T00:00:00Z\u0026#39; }, { \u0026#39;id\u0026#39;: \u0026#39;3\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Nike Air Max\u0026#39;, \u0026#39;price\u0026#39;: 129.99, \u0026#39;category\u0026#39;: \u0026#39;Shoes\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Comfortable running shoes\u0026#39;, \u0026#39;created_at\u0026#39;: \u0026#39;2025-01-01T00:00:00Z\u0026#39; } ] def list_products(self, limit: int = 10, offset: int = 0) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;List products with pagination\u0026#34;\u0026#34;\u0026#34; total = len(self.products) products = self.products[offset:offset + limit] return { \u0026#39;products\u0026#39;: products, \u0026#39;total\u0026#39;: total, \u0026#39;limit\u0026#39;: limit, \u0026#39;offset\u0026#39;: offset, \u0026#39;has_more\u0026#39;: offset + limit \u0026lt; total } def get_product(self, product_id: str) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Get single product by ID\u0026#34;\u0026#34;\u0026#34; for product in self.products: if product[\u0026#39;id\u0026#39;] == product_id: return product return None def create_product(self, product_data: Dict) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Create new product\u0026#34;\u0026#34;\u0026#34; product = { \u0026#39;id\u0026#39;: str(uuid.uuid4()), \u0026#39;name\u0026#39;: product_data.get(\u0026#39;name\u0026#39;), \u0026#39;price\u0026#39;: product_data.get(\u0026#39;price\u0026#39;), \u0026#39;category\u0026#39;: product_data.get(\u0026#39;category\u0026#39;), \u0026#39;description\u0026#39;: product_data.get(\u0026#39;description\u0026#39;, \u0026#39;\u0026#39;), \u0026#39;created_at\u0026#39;: datetime.utcnow().isoformat() + \u0026#39;Z\u0026#39; } self.products.append(product) return product def update_product(self, product_id: str, product_data: Dict) -\u0026gt; Optional[Dict]: \u0026#34;\u0026#34;\u0026#34;Update existing product\u0026#34;\u0026#34;\u0026#34; for i, product in enumerate(self.products): if product[\u0026#39;id\u0026#39;] == product_id: # Update fields product.update({ \u0026#39;name\u0026#39;: product_data.get(\u0026#39;name\u0026#39;, product[\u0026#39;name\u0026#39;]), \u0026#39;price\u0026#39;: product_data.get(\u0026#39;price\u0026#39;, product[\u0026#39;price\u0026#39;]), \u0026#39;category\u0026#39;: product_data.get(\u0026#39;category\u0026#39;, product[\u0026#39;category\u0026#39;]), \u0026#39;description\u0026#39;: product_data.get(\u0026#39;description\u0026#39;, product[\u0026#39;description\u0026#39;]), \u0026#39;updated_at\u0026#39;: datetime.utcnow().isoformat() + \u0026#39;Z\u0026#39; }) self.products[i] = product return product return None def delete_product(self, product_id: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Delete product\u0026#34;\u0026#34;\u0026#34; for i, product in enumerate(self.products): if product[\u0026#39;id\u0026#39;] == product_id: del self.products[i] return True return False EOF 3. Tạo Performance Metrics 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 cat \u0026gt; src/monitoring/performance_metrics.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import boto3 import os import time from datetime import datetime class PerformanceMetrics: def __init__(self): self.cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;) self.namespace = \u0026#39;Lambda/ContainerPerformance\u0026#39; self.function_name = os.environ.get(\u0026#39;AWS_LAMBDA_FUNCTION_NAME\u0026#39;, \u0026#39;workshop-product-api\u0026#39;) def record_request(self, method: str, path: str, status_code: int, duration_ms: float): \u0026#34;\u0026#34;\u0026#34;Record request metrics\u0026#34;\u0026#34;\u0026#34; try: # Record response time self.put_metric(\u0026#39;ResponseTime\u0026#39;, duration_ms, \u0026#39;Milliseconds\u0026#39;, [ {\u0026#39;Name\u0026#39;: \u0026#39;Method\u0026#39;, \u0026#39;Value\u0026#39;: method}, {\u0026#39;Name\u0026#39;: \u0026#39;Path\u0026#39;, \u0026#39;Value\u0026#39;: path} ]) # Record request count self.put_metric(\u0026#39;RequestCount\u0026#39;, 1, \u0026#39;Count\u0026#39;, [ {\u0026#39;Name\u0026#39;: \u0026#39;Method\u0026#39;, \u0026#39;Value\u0026#39;: method}, {\u0026#39;Name\u0026#39;: \u0026#39;StatusCode\u0026#39;, \u0026#39;Value\u0026#39;: str(status_code)} ]) # Record errors if status_code \u0026gt;= 400: self.put_metric(\u0026#39;ErrorCount\u0026#39;, 1, \u0026#39;Count\u0026#39;, [ {\u0026#39;Name\u0026#39;: \u0026#39;StatusCode\u0026#39;, \u0026#39;Value\u0026#39;: str(status_code)} ]) except Exception as e: print(f\u0026#34;Failed to record metrics: {e}\u0026#34;) def put_metric(self, metric_name: str, value: float, unit: str, dimensions: list): \u0026#34;\u0026#34;\u0026#34;Send metric to CloudWatch\u0026#34;\u0026#34;\u0026#34; dimensions.append({ \u0026#39;Name\u0026#39;: \u0026#39;FunctionName\u0026#39;, \u0026#39;Value\u0026#39;: self.function_name }) self.cloudwatch.put_metric_data( Namespace=self.namespace, MetricData=[ { \u0026#39;MetricName\u0026#39;: metric_name, \u0026#39;Value\u0026#39;: value, \u0026#39;Unit\u0026#39;: unit, \u0026#39;Dimensions\u0026#39;: dimensions, \u0026#39;Timestamp\u0026#39;: datetime.utcnow() } ] ) EOF 4. Tạo init.py files 1 2 3 4 5 # Tạo __init__.py files để Python nhận diện packages touch src/__init__.py touch src/api/__init__.py touch src/monitoring/__init__.py touch src/optimizations/__init__.py 5. Tạo test script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 cat \u0026gt; scripts/test-local.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/usr/bin/env python3 import json import sys import os # Add src to path sys.path.insert(0, os.path.join(os.path.dirname(__file__), \u0026#39;..\u0026#39;)) from lambda_function import lambda_handler def test_health_check(): \u0026#34;\u0026#34;\u0026#34;Test health check endpoint\u0026#34;\u0026#34;\u0026#34; event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/health\u0026#39; } response = lambda_handler(event, None) print(\u0026#34;Health Check Test:\u0026#34;) print(f\u0026#34;Status: {response[\u0026#39;statusCode\u0026#39;]}\u0026#34;) print(f\u0026#34;Body: {response[\u0026#39;body\u0026#39;]}\u0026#34;) print() def test_list_products(): \u0026#34;\u0026#34;\u0026#34;Test list products endpoint\u0026#34;\u0026#34;\u0026#34; event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;queryStringParameters\u0026#39;: {\u0026#39;limit\u0026#39;: \u0026#39;2\u0026#39;} } response = lambda_handler(event, None) print(\u0026#34;List Products Test:\u0026#34;) print(f\u0026#34;Status: {response[\u0026#39;statusCode\u0026#39;]}\u0026#34;) print(f\u0026#34;Body: {response[\u0026#39;body\u0026#39;]}\u0026#34;) print() def test_get_product(): \u0026#34;\u0026#34;\u0026#34;Test get single product\u0026#34;\u0026#34;\u0026#34; event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products/1\u0026#39;, \u0026#39;pathParameters\u0026#39;: {\u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;} } response = lambda_handler(event, None) print(\u0026#34;Get Product Test:\u0026#34;) print(f\u0026#34;Status: {response[\u0026#39;statusCode\u0026#39;]}\u0026#34;) print(f\u0026#34;Body: {response[\u0026#39;body\u0026#39;]}\u0026#34;) print() if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#34;=== Kiểm thử Lambda Function Locally ===\u0026#34;) test_health_check() test_list_products() test_get_product() print(\u0026#34;=== Tests Completed ===\u0026#34;) EOF chmod +x scripts/test-local.py Test ứng dụng locally 1 2 # Chạy test python3 scripts/test-local.py Kết luận Bạn đã tạo th à nh c ô ng:\n✅ Lambda function handler với routing ✅ Product service với CRUD operations ✅ Hi ệ u su ấ t metrics tracking ✅ Local Kiểm thử capability Ứng dụng này s ử dụng mock data để demo. Trong M ô i tr ườ ng sản xuất, bạn sẽ kết n ố i với DynamoDB ho ặ c database th ự c t ế.\nTiếp theo, chúng ta sẽ tạo Docker container cho ứng dụng này.\n"
},
{
	"uri": "//localhost:1313/vi/",
	"title": "Tối ưu hóa hiệu suất AWS Lambda Container Images",
	"tags": [],
	"description": "",
	"content": "Tối ưu hóa hiệu suất AWS Lambda Container Images Tổng quan Trong workshop toàn diện này, bạn sẽ thành thạo nghệ thuật tối ưu hóa AWS Lambda Container Images để đạt hiệu suất vượt trội. Học cách đạt được Cold Start dưới 1 giây, tối ưu hóa việc sử dụng bộ nhớ, triển khai các chiến lược caching tiên tiến, và thiết lập monitoring toàn diện cho các ứng dụng serverless cấp production.\nMục tiêu Workshop Tối ưu hóa Cold Start: Đạt được thời gian Cold Start \u0026lt; 1s Memory Profiling: Tối ưu hóa việc sử dụng và phân bổ bộ nhớ Performance Benchmarking: Đo lường và xác thực các cải tiến Phân tích Chi phí: Giảm chi phí vận hành thông qua tối ưu hóa Monitoring \u0026amp; Alerting: Triển khai observability toàn diện Best Practices Vận hành: Các chiến lược deployment sẵn sàng cho production Nội dung Giới thiệu \u0026amp; Kiến trúc Yêu cầu \u0026amp; Thiết lập môi trường Tối ưu hóa Container Image Performance Monitoring \u0026amp; Profiling Chiến lược Caching \u0026amp; Warm-up Phân tích Chi phí \u0026amp; Benchmarking Triển khai Production Dọn dẹp tài nguyên "
},
{
	"uri": "//localhost:1313/vi/3-container-optimization/3.2-build-container/",
	"title": "Build và Push Container Images",
	"tags": [],
	"description": "",
	"content": "Build và Push Container Images Tổng quan Trong phần này, chúng ta sẽ tạo Docker Container Images cho Lambda function và push l ê n Amazon ECR.\nTạo Dockerfile 1. Dockerfile cơ bản 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 cd ~/lambda-container-workshop cat \u0026gt; docker/base/Dockerfile \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Sử dụng AWS Lambda Python base image FROM public.ecr.aws/lambda/python:3.11 # Copy requirements và install dependencies COPY requirements.txt ${LAMBDA_TASK_ROOT}/ RUN pip install --no-cache-dir -r requirements.txt # Copy application code COPY lambda_function.py ${LAMBDA_TASK_ROOT}/ COPY src/ ${LAMBDA_TASK_ROOT}/src/ # Set the CMD to your handler CMD [\u0026#34;lambda_function.lambda_handler\u0026#34;] EOF 2. Dockerfile tối ưu hóa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 cat \u0026gt; docker/optimized/Dockerfile \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Multi-stage build để tối ưu hóa size FROM public.ecr.aws/lambda/python:3.11 as builder # Install build dependencies RUN yum update -y \u0026amp;\u0026amp; \\ yum install -y gcc python3-devel \u0026amp;\u0026amp; \\ yum clean all # Copy requirements và install vào thư mục riêng COPY requirements.txt . RUN pip install --no-cache-dir --target /opt/python -r requirements.txt # Remove unnecessary files để giảm size RUN find /opt/python -name \u0026#34;*.pyc\u0026#34; -delete \u0026amp;\u0026amp; \\ find /opt/python -name \u0026#34;__pycache__\u0026#34; -type d -exec rm -rf {} + \u0026amp;\u0026amp; \\ find /opt/python -name \u0026#34;*.so\u0026#34; -exec strip {} \\; 2\u0026gt;/dev/null || true # Production environment stage FROM public.ecr.aws/lambda/python:3.11 # Copy optimized dependencies COPY --from=builder /opt/python ${LAMBDA_TASK_ROOT}/ # Copy application code COPY lambda_function.py ${LAMBDA_TASK_ROOT}/ COPY src/ ${LAMBDA_TASK_ROOT}/src/ # Set environment variables for optimization ENV PYTHONPATH=\u0026#34;${LAMBDA_TASK_ROOT}/src:${PYTHONPATH}\u0026#34; ENV PYTHONDONTWRITEBYTECODE=1 ENV PYTHONUNBUFFERED=1 ENV PYTHONHASHSEED=0 # Pre-compile Python bytecode RUN python -m compileall -b ${LAMBDA_TASK_ROOT} \u0026amp;\u0026amp; \\ find ${LAMBDA_TASK_ROOT} -name \u0026#34;*.py\u0026#34; -not -path \u0026#34;*/tests/*\u0026#34; -delete # Set the CMD to your handler CMD [\u0026#34;lambda_function.lambda_handler\u0026#34;] EOF 3. Tạo .dockerignore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 cat \u0026gt; .dockerignore \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Git .git .gitignore # Python __pycache__ *.pyc *.pyo *.pyd .Python env pip-log.txt pip-delete-this-directory.txt .tox .coverage .coverage.* .cache nosetests.xml coverage.xml *.cover *.log .git .mypy_cache .pytest_cache .hypothesis # OS .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db # IDE .vscode .idea # Docker Dockerfile* docker-compose* # Tests tests/ *.test # Documentation README.md docs/ EOF Build Scripts 1. Script build image cơ bản 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cat \u0026gt; scripts/build-base.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash set -e echo \u0026#34;=== Building Base Container Image ===\u0026#34; # Load configuration ECR_REGISTRY=$(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4) REPOSITORY=\u0026#34;${ECR_REGISTRY}/lambda-workshop/product-api\u0026#34; TAG=\u0026#34;base-$(date +%Y%m%d-%H%M%S)\u0026#34; echo \u0026#34;Building image: $REPOSITORY:$TAG\u0026#34; # Build image docker build \\ -f docker/base/Dockerfile \\ -t $REPOSITORY:$TAG \\ -t $REPOSITORY:base-latest \\ . echo \u0026#34;✅ Build completed: $REPOSITORY:$TAG\u0026#34; # Show image size echo \u0026#34;Image size:\u0026#34; docker images $REPOSITORY:$TAG --format \u0026#34;table {{.Repository}}:{{.Tag}}\\t{{.Size}}\u0026#34; echo \u0026#34;Image built successfully!\u0026#34; echo \u0026#34;Tag: $TAG\u0026#34; EOF chmod +x scripts/build-base.sh 2. Script build image tối ưu 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cat \u0026gt; scripts/build-optimized.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash set -e echo \u0026#34;=== Building Optimized Container Image ===\u0026#34; # Load configuration ECR_REGISTRY=$(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4) REPOSITORY=\u0026#34;${ECR_REGISTRY}/lambda-workshop/product-api\u0026#34; TAG=\u0026#34;optimized-$(date +%Y%m%d-%H%M%S)\u0026#34; echo \u0026#34;Building optimized image: $REPOSITORY:$TAG\u0026#34; # Build image với BuildKit để tối ưu hóa DOCKER_BUILDKIT=1 docker build \\ -f docker/optimized/Dockerfile \\ -t $REPOSITORY:$TAG \\ -t $REPOSITORY:optimized-latest \\ . echo \u0026#34;✅ Build completed: $REPOSITORY:$TAG\u0026#34; # Show image size echo \u0026#34;Image size:\u0026#34; docker images $REPOSITORY:$TAG --format \u0026#34;table {{.Repository}}:{{.Tag}}\\t{{.Size}}\u0026#34; echo \u0026#34;Optimized image built successfully!\u0026#34; echo \u0026#34;Tag: $TAG\u0026#34; EOF chmod +x scripts/build-optimized.sh 3. Script push images 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 cat \u0026gt; scripts/push-images.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash set -e IMAGE_TAG=${1:-\u0026#34;latest\u0026#34;} IMAGE_TYPE=${2:-\u0026#34;optimized\u0026#34;} if [ \u0026#34;$IMAGE_TYPE\u0026#34; != \u0026#34;base\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$IMAGE_TYPE\u0026#34; != \u0026#34;optimized\u0026#34; ]; then echo \u0026#34;Usage: $0 [tag] [base|optimized]\u0026#34; echo \u0026#34;Example: $0 latest optimized\u0026#34; exit 1 fi echo \u0026#34;=== Pushing Container Images to ECR ===\u0026#34; # Load configuration ECR_REGISTRY=$(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4) REPOSITORY=\u0026#34;${ECR_REGISTRY}/lambda-workshop/product-api\u0026#34; # Login to ECR echo \u0026#34;Logging in to ECR...\u0026#34; aws ecr get-login-password --region us-east-1 | \\ docker login --username AWS --password-stdin $ECR_REGISTRY # Push specific tag if [ \u0026#34;$IMAGE_TAG\u0026#34; != \u0026#34;latest\u0026#34; ]; then echo \u0026#34;Pushing $REPOSITORY:${IMAGE_TYPE}-${IMAGE_TAG}\u0026#34; docker push $REPOSITORY:${IMAGE_TYPE}-${IMAGE_TAG} fi # Push latest tag echo \u0026#34;Pushing $REPOSITORY:${IMAGE_TYPE}-latest\u0026#34; docker push $REPOSITORY:${IMAGE_TYPE}-latest echo \u0026#34;✅ Images pushed successfully!\u0026#34; # Show pushed images echo \u0026#34;Pushed images:\u0026#34; aws ecr list-images \\ --repository-name lambda-workshop/product-api \\ --query \u0026#39;imageIds[*].imageTag\u0026#39; \\ --output table EOF chmod +x scripts/push-images.sh Build và Push Images 1. Build base image 1 2 # Build base image ./scripts/build-base.sh 2. Build optimized image 1 2 # Build optimized image ./scripts/build-optimized.sh 3. So sánh kích thước images 1 2 3 # So sánh kích thước echo \u0026#34;=== Image Size Comparison ===\u0026#34; docker images | grep lambda-workshop/product-api | head -5 4. Push images lên ECR 1 2 3 4 5 # Push optimized image ./scripts/push-images.sh latest optimized # Push base image (optional) ./scripts/push-images.sh latest base Test Container Locally 1. Test base image 1 2 3 # Chạy container locally docker run -p 9000:8080 \\ $(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4)/lambda-workshop/product-api:base-latest 2. Test với curl (terminal khác) 1 2 3 4 5 6 7 # Test health check curl -XPOST \u0026#34;http://localhost:9000/2015-03-31/functions/function/invocations\u0026#34; \\ -d \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/health\u0026#34;}\u0026#39; # Test list products curl -XPOST \u0026#34;http://localhost:9000/2015-03-31/functions/function/invocations\u0026#34; \\ -d \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;,\u0026#34;queryStringParameters\u0026#34;:{\u0026#34;limit\u0026#34;:\u0026#34;2\u0026#34;}}\u0026#39; 3. Script test container 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 cat \u0026gt; scripts/test-container.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash IMAGE_TYPE=${1:-\u0026#34;optimized\u0026#34;} ECR_REGISTRY=$(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4) IMAGE=\u0026#34;${ECR_REGISTRY}/lambda-workshop/product-api:${IMAGE_TYPE}-latest\u0026#34; echo \u0026#34;Kiểm thử container: $IMAGE\u0026#34; # Start container in background CONTAINER_ID=$(docker run -d -p 9000:8080 $IMAGE) echo \u0026#34;Started container: $CONTAINER_ID\u0026#34; # Wait for container to start sleep 3 # Test health check echo \u0026#34;Kiểm thử health check...\u0026#34; RESPONSE=$(curl -s -XPOST \u0026#34;http://localhost:9000/2015-03-31/functions/function/invocations\u0026#34; \\ -d \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/health\u0026#34;}\u0026#39;) echo \u0026#34;Health check response: $RESPONSE\u0026#34; # Test list products echo \u0026#34;Kiểm thử list products...\u0026#34; RESPONSE=$(curl -s -XPOST \u0026#34;http://localhost:9000/2015-03-31/functions/function/invocations\u0026#34; \\ -d \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;}\u0026#39;) echo \u0026#34;List products response: $RESPONSE\u0026#34; # Stop container docker stop $CONTAINER_ID docker rm $CONTAINER_ID echo \u0026#34;✅ Container test completed\u0026#34; EOF chmod +x scripts/test-container.sh 1 2 # Test optimized container ./scripts/test-container.sh optimized Kết luận Bạn đã ho à n th à nh:\n✅ Tạo Dockerfile c ơ b ả n và t ố i ư u h ó a ✅ Build Container Images với multi-stage builds ✅ Push images l ê n Amazon ECR ✅ Test containers locally ✅ So s á nh k í ch th ướ c images Image t ố i ư u h ó a th ườ ng nh ỏ h ơ n 30-50% so với base image nh ờ các k ỹ thuật:\nMulti-stage builds Loại b ỏ build dependencies Pre-compile Python bytecode Strip binary files Tiếp theo, chúng ta sẽ tạo Lambda functions từcác Container Images này.\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/",
	"title": "Các bước chuẩn bị",
	"tags": [],
	"description": "",
	"content": "\rĐể thực hiện workshop này, bạn cần có một EC2 Linux instance với quyền truy cập AWS để build và deploy Lambda Container Images.\nTrong workshop này, chúng ta sẽ tối ưu hóa hiệu suất AWS Lambda Container Images. Để thực hiện được các bài thực hành, bạn cần chuẩn bị:\nEC2 Instance: Một Linux instance để build Docker images và chạy AWS CLI IAM Permissions: Quy ề n để tạo và qu ả n l ý Lambda functions, ECR repositories Development Environment: Docker, AWS CLI, và các công cụ ph á t tri ể n c ầ n thiết Để t ì m hi ể u cách tạo các EC2 instance và VPC với public/private subnet các bạn c ó th ể tham kh ả o b à i lab:\nGiới thiệu về Amazon EC2 Làm việc với Amazon VPC Nội dung Chu ẩ n b ị VPC và EC2 Instance Tạo IAM Role Thiết lập môi trường phát triển "
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.2-createiamrole/",
	"title": "Tạo IAM Role cho Lambda Container",
	"tags": [],
	"description": "",
	"content": "Tạo IAM Role cho Lambda Container Workshop Trong bước này, chúng ta sẽ tạo các IAM role cần thiết cho Lambda Container functions và EC2 development instance. Các role này sẽ cung cấp quyền cần thiết cho container operations, Lambda management, và AWS service integrations.\nTạo Lambda Execution Role Truy cập giao diện quản trị dịch vụ IAM Trong thanh điều hướng bên trái, nhấp Roles. Nhấp Create role. Tại Trusted entity type, chọn AWS service. Tại Use case, chọn Lambda. Nhấp Next. Trong phần Permissions policies:\nTìm kiếm và chọn AWSLambdaBasicExecutionRole Tìm kiếm và chọn AmazonEC2ContainerRegistryReadOnly Chúng ta sẽ thêm custom policies sau Nhấp Next.\nTại Role name, nhập lambda-container-workshop-role.\nTại Description, nhập Execution role for Lambda container functions in workshop.\nNhấp Create role.\nTạo Custom Policy cho Lambda Container Trong IAM console, nhấp Policies trong thanh điều hướng bên trái. Nhấp Create policy. Nhấp tab JSON và dán policy sau: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;CloudWatchMetrics\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;cloudwatch:PutMetricData\u0026#34;, \u0026#34;cloudwatch:GetMetricStatistics\u0026#34;, \u0026#34;cloudwatch:ListMetrics\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;SecretsManager\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;secretsmanager:GetSecretValue\u0026#34;, \u0026#34;secretsmanager:DescribeSecret\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:secretsmanager:*:*:secret:lambda-workshop/*\u0026#34; }, { \u0026#34;Sid\u0026#34;: \u0026#34;XRayTracing\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;xray:PutTraceSegments\u0026#34;, \u0026#34;xray:PutTelemetryRecords\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Nhấp Next. Tại Policy name, nhập LambdaContainerWorkshopPolicy. Nhấp Create policy. Gắn Custom Policy vào Lambda Role Quay lại Roles và tìm lambda-container-workshop-role. Nhấp vào tên role. Nhấp Add permissions → Attach policies. Tìm kiếm và chọn LambdaContainerWorkshopPolicy. Nhấp Add permissions. Tạo EC2 Development Role Nhấp Create role.\nChọn AWS service → EC2.\nNhấp Next.\nTìm kiếm và gắn các policies sau:\nAmazonEC2ContainerRegistryFullAccess AWSLambda_FullAccess CloudWatchFullAccess AmazonAPIGatewayAdministrator SecretsManagerReadWrite Nhấp Next.\nTại Role name, nhập ec2-lambda-development-role.\nNhấp Create role.\nTạo Instance Profile Truy cập Roles và tìm ec2-lambda-development-role. Ghi chú role ARN để sử dụng sau. Tạo instance profile qua AWS CLI: 1 2 aws iam create-instance-profile --instance-profile-name ec2-lambda-development-profile aws iam add-role-to-instance-profile --instance-profile-name ec2-lambda-development-profile --role-name ec2-lambda-development-role Xác minh Xác minh các role được tạo đúng cách:\n1 2 3 4 5 6 # Liệt kê roles aws iam list-roles --query \u0026#39;Roles[?contains(RoleName, `lambda-container-workshop`) || contains(RoleName, `ec2-lambda-development`)].RoleName\u0026#39; # Lấy chi tiết role aws iam get-role --role-name lambda-container-workshop-role aws iam get-role --role-name ec2-lambda-development-role Các IAM role này cung cấp quyền cần thiết cho:\nLambda functions để thực thi và truy cập AWS services EC2 instance để quản lý Lambda functions và container images CloudWatch monitoring và logging Secrets Manager cho cấu hình bảo mật Các IAM role hiện đã sẵn sàng để sử dụng trong Lambda Container workshop.\n"
},
{
	"uri": "//localhost:1313/vi/3-container-optimization/3.3-create-lambda/",
	"title": "Tạo Lambda Functions",
	"tags": [],
	"description": "",
	"content": "Tạo Lambda Functions Tổng quan Trong phần này, chúng ta sẽ tạo Lambda functions từContainer Images đã build và so s á nh hiệu suất gi ữ a base và optimized versions.\nTạo IAM Role cho Lambda 1. Tạo trust policy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 cd ~/lambda-container-workshop cat \u0026gt; lambda-trust-policy.json \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;lambda.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } EOF 2. Tạo IAM role 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Tạo IAM role aws iam create-role \\ --role-name lambda-container-workshop-role \\ --assume-role-policy-document file://lambda-trust-policy.json # Attach basic execution policy aws iam attach-role-policy \\ --role-name lambda-container-workshop-role \\ --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole # Attach CloudWatch policy cho custom metrics aws iam attach-role-policy \\ --role-name lambda-container-workshop-role \\ --policy-arn arn:aws:iam::aws:policy/CloudWatchFullAccess # Lấy ARN của role ROLE_ARN=$(aws iam get-role \\ --role-name lambda-container-workshop-role \\ --query \u0026#39;Role.Arn\u0026#39; \\ --output text) echo \u0026#34;Role ARN: $ROLE_ARN\u0026#34; Tạo Lambda Functions 1. Script tạo Lambda function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 cat \u0026gt; scripts/create-lambda.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash set -e FUNCTION_NAME=${1:-\u0026#34;workshop-product-api\u0026#34;} IMAGE_TYPE=${2:-\u0026#34;optimized\u0026#34;} MEMORY_SIZE=${3:-512} if [ -z \u0026#34;$FUNCTION_NAME\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;function-name\u0026gt; [base|optimized] [memory-size]\u0026#34; echo \u0026#34;Example: $0 workshop-product-api optimized 512\u0026#34; exit 1 fi echo \u0026#34;=== Creating Lambda Function ===\u0026#34; echo \u0026#34;Function Name: $FUNCTION_NAME\u0026#34; echo \u0026#34;Image Type: $IMAGE_TYPE\u0026#34; echo \u0026#34;Memory Size: ${MEMORY_SIZE}MB\u0026#34; # Load configuration ECR_REGISTRY=$(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4) IMAGE_URI=\u0026#34;${ECR_REGISTRY}/lambda-workshop/product-api:${IMAGE_TYPE}-latest\u0026#34; ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text) ROLE_ARN=\u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/lambda-container-workshop-role\u0026#34; echo \u0026#34;Image URI: $IMAGE_URI\u0026#34; echo \u0026#34;Role ARN: $ROLE_ARN\u0026#34; # Check if function exists if AWS Lambda get-function --function-name $FUNCTION_NAME \u0026amp;\u0026gt;/dev/null; then echo \u0026#34;Function exists, updating...\u0026#34; # Update function code AWS Lambda update-function-code \\ --function-name $FUNCTION_NAME \\ --image-uri $IMAGE_URI # Update function configuration AWS Lambda update-function-configuration \\ --function-name $FUNCTION_NAME \\ --memory-size $MEMORY_SIZE \\ --timeout 30 \\ --environment Variables=\u0026#39;{ \u0026#34;ENVIRONMENT\u0026#34;:\u0026#34;workshop\u0026#34;, \u0026#34;LOG_LEVEL\u0026#34;:\u0026#34;INFO\u0026#34; }\u0026#39; echo \u0026#34;✅ Function updated: $FUNCTION_NAME\u0026#34; else echo \u0026#34;Creating new function...\u0026#34; # Create function AWS Lambda create-function \\ --function-name $FUNCTION_NAME \\ --role $ROLE_ARN \\ --code ImageUri=$IMAGE_URI \\ --package-type Image \\ --memory-size $MEMORY_SIZE \\ --timeout 30 \\ --Kiến trúc x86_64 \\ --environment Variables=\u0026#39;{ \u0026#34;ENVIRONMENT\u0026#34;:\u0026#34;workshop\u0026#34;, \u0026#34;LOG_LEVEL\u0026#34;:\u0026#34;INFO\u0026#34; }\u0026#39; \\ --description \u0026#34;Workshop Lambda function using container image ($IMAGE_TYPE)\u0026#34; echo \u0026#34;✅ Function created: $FUNCTION_NAME\u0026#34; fi # Wait for function to be active echo \u0026#34;Waiting for function to be active...\u0026#34; AWS Lambda wait function-active --function-name $FUNCTION_NAME # Get function info AWS Lambda get-function \\ --function-name $FUNCTION_NAME \\ --query \u0026#39;{ FunctionName: Configuration.FunctionName, Runtime: Configuration.PackageType, MemorySize: Configuration.MemorySize, Timeout: Configuration.Timeout, CodeSize: Configuration.CodeSize, LastModified: Configuration.LastModified }\u0026#39; \\ --output table echo \u0026#34;Function ready for Kiểm thử!\u0026#34; EOF chmod +x scripts/create-lambda.sh 2. Tạo cả hai versions 1 2 3 4 5 # Tạo optimized version ./scripts/create-lambda.sh workshop-product-api-optimized optimized 512 # Tạo base version để so sánh ./scripts/create-lambda.sh workshop-product-api-base base 512 Tạo API Gateway (Optional) 1. Script tạo API Gateway 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 cat \u0026gt; scripts/create-api-gateway.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash set -e FUNCTION_NAME=${1:-\u0026#34;workshop-product-api-optimized\u0026#34;} API_NAME=\u0026#34;workshop-product-api\u0026#34; echo \u0026#34;=== Creating API Gateway ===\u0026#34; # Create REST API API_ID=$(aws apigateway create-rest-api \\ --name $API_NAME \\ --description \u0026#34;Workshop Product API\u0026#34; \\ --query \u0026#39;id\u0026#39; \\ --output text) echo \u0026#34;API ID: $API_ID\u0026#34; # Get root resource ID ROOT_RESOURCE_ID=$(aws apigateway get-resources \\ --rest-api-id $API_ID \\ --query \u0026#39;items[0].id\u0026#39; \\ --output text) # Create {proxy+} resource PROXY_RESOURCE_ID=$(aws apigateway create-resource \\ --rest-api-id $API_ID \\ --parent-id $ROOT_RESOURCE_ID \\ --path-part \u0026#39;{proxy+}\u0026#39; \\ --query \u0026#39;id\u0026#39; \\ --output text) # Create ANY method aws apigateway put-method \\ --rest-api-id $API_ID \\ --resource-id $PROXY_RESOURCE_ID \\ --http-method ANY \\ --authorization-type NONE # Get Lambda function ARN ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text) LAMBDA_ARN=\u0026#34;arn:aws:lambda:us-east-1:${ACCOUNT_ID}:function:${FUNCTION_NAME}\u0026#34; # Set up integration aws apigateway put-integration \\ --rest-api-id $API_ID \\ --resource-id $PROXY_RESOURCE_ID \\ --http-method ANY \\ --type AWS_PROXY \\ --integration-http-method POST \\ --uri \u0026#34;arn:aws:apigateway:us-east-1:lambda:path/2015-03-31/functions/${LAMBDA_ARN}/invocations\u0026#34; # Add Lambda permission AWS Lambda add-permission \\ --function-name $FUNCTION_NAME \\ --statement-id api-gateway-invoke \\ --action lambda:InvokeFunction \\ --principal apigateway.amazonaws.com \\ --source-arn \u0026#34;arn:aws:execute-api:us-east-1:${ACCOUNT_ID}:${API_ID}/*/*\u0026#34; # Deploy API aws apigateway create-Triển khai \\ --rest-api-id $API_ID \\ --stage-name prod # Get API endpoint API_ENDPOINT=\u0026#34;https://${API_ID}.execute-api.us-east-1.amazonaws.com/prod\u0026#34; echo \u0026#34;✅ API Gateway created!\u0026#34; echo \u0026#34;API Endpoint: $API_ENDPOINT\u0026#34; # Save endpoint to config echo \u0026#34;API_ENDPOINT=$API_ENDPOINT\u0026#34; \u0026gt;\u0026gt; ~/.bashrc EOF chmod +x scripts/create-api-gateway.sh 1 2 # Tạo API Gateway cho optimized function ./scripts/create-api-gateway.sh workshop-product-api-optimized Test Lambda Functions 1. Script test Lambda function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 cat \u0026gt; scripts/test-lambda.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash FUNCTION_NAME=${1:-\u0026#34;workshop-product-api-optimized\u0026#34;} echo \u0026#34;=== Kiểm thử Lambda Function: $FUNCTION_NAME ===\u0026#34; # Test 1: Health Check echo \u0026#34;1. Kiểm thử Health Check...\u0026#34; AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/health\u0026#34;}\u0026#39; \\ response.json echo \u0026#34;Response:\u0026#34; cat response.json | jq . echo # Test 2: List Products echo \u0026#34;2. Kiểm thử List Products...\u0026#34; AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;,\u0026#34;queryStringParameters\u0026#34;:{\u0026#34;limit\u0026#34;:\u0026#34;2\u0026#34;}}\u0026#39; \\ response.json echo \u0026#34;Response:\u0026#34; cat response.json | jq . echo # Test 3: Get Single Product echo \u0026#34;3. Kiểm thử Get Product...\u0026#34; AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/products/1\u0026#34;,\u0026#34;pathParameters\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;1\u0026#34;}}\u0026#39; \\ response.json echo \u0026#34;Response:\u0026#34; cat response.json | jq . echo # Test 4: Create Product echo \u0026#34;4. Kiểm thử Create Product...\u0026#34; AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#39;{ \u0026#34;httpMethod\u0026#34;:\u0026#34;POST\u0026#34;, \u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;, \u0026#34;body\u0026#34;:\u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;Test Product\\\u0026#34;,\\\u0026#34;price\\\u0026#34;:99.99,\\\u0026#34;category\\\u0026#34;:\\\u0026#34;Test\\\u0026#34;}\u0026#34; }\u0026#39; \\ response.json echo \u0026#34;Response:\u0026#34; cat response.json | jq . echo # Dọn dẹp rm -f response.json echo \u0026#34;✅ Lambda function tests completed!\u0026#34; EOF chmod +x scripts/test-lambda.sh 2. Test cả hai functions 1 2 3 4 5 # Test optimized function ./scripts/test-lambda.sh workshop-product-api-optimized # Test base function ./scripts/test-lambda.sh workshop-product-api-base 3. Hiệu suất comparison script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 cat \u0026gt; scripts/compare-hiệu suất.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash echo \u0026#34;=== Hiệu suất Comparison ===\u0026#34; OPTIMIZED_FUNCTION=\u0026#34;workshop-product-api-optimized\u0026#34; BASE_FUNCTION=\u0026#34;workshop-product-api-base\u0026#34; echo \u0026#34;Kiểm thử both functions with same payload...\u0026#34; # Test payload PAYLOAD=\u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;,\u0026#34;queryStringParameters\u0026#34;:{\u0026#34;limit\u0026#34;:\u0026#34;5\u0026#34;}}\u0026#39; echo \u0026#34;1. Kiểm thử Optimized Function...\u0026#34; time AWS Lambda invoke \\ --function-name $OPTIMIZED_FUNCTION \\ --payload \u0026#34;$PAYLOAD\u0026#34; \\ optimized-response.json echo \u0026#34;2. Kiểm thử Base Function...\u0026#34; time AWS Lambda invoke \\ --function-name $BASE_FUNCTION \\ --payload \u0026#34;$PAYLOAD\u0026#34; \\ base-response.json echo \u0026#34;=== Results ===\u0026#34; echo \u0026#34;Optimized Function Response:\u0026#34; cat optimized-response.json | jq . echo \u0026#34;Base Function Response:\u0026#34; cat base-response.json | jq . # Dọn dẹp rm -f optimized-response.json base-response.json echo \u0026#34;✅ Hiệu suất comparison completed!\u0026#34; EOF chmod +x scripts/compare-hiệu suất.sh 1 2 # So sánh hiệu suất ./scripts/compare-hiệu suất.sh monitoring Setup 1. Tạo CloudWatch Dashboard 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 cat \u0026gt; scripts/create-dashboard.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash DASHBOARD_NAME=\u0026#34;Lambda-Container-Workshop\u0026#34; echo \u0026#34;=== Creating CloudWatch Dashboard ===\u0026#34; # Create dashboard aws CloudWatch put-dashboard \\ --dashboard-name $DASHBOARD_NAME \\ --dashboard-body \u0026#39;{ \u0026#34;widgets\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;x\u0026#34;: 0, \u0026#34;y\u0026#34;: 0, \u0026#34;width\u0026#34;: 12, \u0026#34;height\u0026#34;: 6, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [ \u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Duration\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;workshop-product-api-optimized\u0026#34; ], [ \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;workshop-product-api-base\u0026#34; ] ], \u0026#34;period\u0026#34;: 300, \u0026#34;stat\u0026#34;: \u0026#34;Average\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Function Duration Comparison\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;x\u0026#34;: 0, \u0026#34;y\u0026#34;: 6, \u0026#34;width\u0026#34;: 12, \u0026#34;height\u0026#34;: 6, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [ \u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Invocations\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;workshop-product-api-optimized\u0026#34; ], [ \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;workshop-product-api-base\u0026#34; ] ], \u0026#34;period\u0026#34;: 300, \u0026#34;stat\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Function Invocations\u0026#34; } } ] }\u0026#39; echo \u0026#34;✅ Dashboard created: $DASHBOARD_NAME\u0026#34; echo \u0026#34;View at: https://console.aws.amazon.com/CloudWatch/home?region=us-east-1#dashboards:name=$DASHBOARD_NAME\u0026#34; EOF chmod +x scripts/create-dashboard.sh ./scripts/create-dashboard.sh Kết luận Bạn đã ho à n th à nh:\n✅ Tạo IAM role cho Lambda functions ✅ Tạo Lambda functions từContainer Images ✅ Tạo API Gateway endpoint (optional) ✅ Test functions với nhi ề u scenarios ✅ So s á nh hiệu suất gi ữ a base và optimized versions ✅ Thiết lập CloudWatch giám sát (Monitoring) Lambda functions đã s ẵ n s à ng! Bạn c ó th ể th ấ y s ự kh á c bi ệ t v ề hiệu suất gi ữ a base và optimized Container Images.\nTiếp theo, chúng ta sẽ đ i s â u và o giám sát (Giám sát) và Ph â n t í ch hiệu suất (Phân tích hiệu suất) để đ o l ườ ng hiệu suất chi tiết h ơ n.\n"
},
{
	"uri": "//localhost:1313/vi/2-prerequiste/2.3-setup-environment/",
	"title": "Thiết lập môi trường phát triển",
	"tags": [],
	"description": "",
	"content": "Thiết lập môi trường phát triển Tổng quan Trong phần này, chúng ta sẽ thiết lập môi trường phát triển c ầ n thiết để build và deploy Lambda Container Images.\nCài đặt công cụ cần thiết 1. Cài đặt Docker Tr ê n EC2 Linux instance:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Cập nhật hệ thống sudo yum update -y # Cài đặt Docker sudo yum install -y docker # Khởi động Docker service sudo systemctl start docker sudo systemctl enable docker # Thêm user vào docker group sudo usermod -a -G docker ec2-user # Logout và login lại để áp dụng thay đổi exit Sau khi login lại, ki ể m tra Docker:\n1 2 docker --version docker run hello-world 2. Cài đặt AWS CLI v2 1 2 3 4 5 6 7 8 9 10 # Tải và cài đặt AWS CLI v2 curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o \u0026#34;awscliv2.zip\u0026#34; unzip awscliv2.zip sudo ./aws/install # Kiểm tra version aws --version # Kiểm tra credentials (nếu sử dụng IAM role) aws sts get-caller-identity 3. Cài đặt Python và các công cụ bổ sung 1 2 3 4 5 6 7 8 9 10 # Cài đặt Python 3.11 (để match với Lambda runtime) sudo yum install -y python3.11 python3.11-pip # Cài đặt các công cụ bổ sung sudo yum install -y jq git bc tree # Tạo alias cho python3.11 echo \u0026#39;alias python3=python3.11\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;alias pip3=pip3.11\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc Tạo ECR Repository 1. Tạo repository cho Container Images 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Tạo ECR repository aws ecr create-repository \\ --repository-name lambda-workshop/product-api \\ --region us-east-1 # Lấy URI của repository export ECR_REGISTRY=$(aws ecr describe-repositories \\ --repository-names lambda-workshop/product-api \\ --query \u0026#39;repositories[0].repositoryUri\u0026#39; \\ --output text | cut -d\u0026#39;/\u0026#39; -f1) echo \u0026#34;ECR Registry: $ECR_REGISTRY\u0026#34; # Lưu vào file để sử dụng sau echo \u0026#34;export ECR_REGISTRY=$ECR_REGISTRY\u0026#34; \u0026gt;\u0026gt; ~/.bashrc 2. Đăng nhập Docker vào ECR 1 2 3 4 5 # Đăng nhập Docker vào ECR aws ecr get-login-password --region us-east-1 | \\ docker login --username AWS --password-stdin $ECR_REGISTRY echo \u0026#34;✅ Đã đăng nhập thành công vào ECR\u0026#34; Tạo cấu trúc project 1. Tạo thư mục project 1 2 3 4 5 6 7 8 9 10 11 # Tạo thư mục chính mkdir -p ~/lambda-container-workshop cd ~/lambda-container-workshop # Tạo cấu trúc thư mục mkdir -p {src,scripts,docker,tests} mkdir -p src/{api,monitoring,optimizations} mkdir -p docker/{base,optimized} # Hiển thị cấu trúc tree 2. Tạo file requirements.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 cat \u0026gt; requirements.txt \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Core AWS dependencies boto3==1.34.0 botocore==1.34.0 # HTTP requests requests==2.31.0 urllib3==1.26.18 # JSON processing ujson==5.8.0 # Performance monitoring psutil==5.9.6 EOF 3. Tạo file .gitignore 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 cat \u0026gt; .gitignore \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Python __pycache__/ *.py[cod] *$py.class *.so .Python env/ venv/ # AWS .aws/ *.pem # Docker .dockerignore # IDE .vscode/ .idea/ # Logs *.log # Build artifacts build/ dist/ *.egg-info/ EOF Kiểm tra môi trường 1. Tạo script kiểm tra 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 cat \u0026gt; scripts/check-environment.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash echo \u0026#34;=== Kiểm tra môi trường phát triển ===\u0026#34; # Kiểm tra Docker echo -n \u0026#34;Docker: \u0026#34; if command -v docker \u0026amp;\u0026gt; /dev/null \u0026amp;\u0026amp; docker info \u0026amp;\u0026gt; /dev/null; then echo \u0026#34;✅ $(docker --version)\u0026#34; else echo \u0026#34;❌ Chưa cài đặt hoặc không chạy\u0026#34; fi # Kiểm tra AWS CLI echo -n \u0026#34;AWS CLI: \u0026#34; if command -v aws \u0026amp;\u0026gt; /dev/null; then echo \u0026#34;✅ $(aws --version)\u0026#34; else echo \u0026#34;❌ Chưa cài đặt\u0026#34; fi # Kiểm tra Python echo -n \u0026#34;Python 3.11: \u0026#34; if command -v python3.11 \u0026amp;\u0026gt; /dev/null; then echo \u0026#34;✅ $(python3.11 --version)\u0026#34; else echo \u0026#34;❌ Chưa cài đặt\u0026#34; fi # Kiểm tra AWS credentials echo -n \u0026#34;AWS Credentials: \u0026#34; if aws sts get-caller-identity \u0026amp;\u0026gt; /dev/null; then echo \u0026#34;✅ Account: $(aws sts get-caller-identity --query \u0026#39;Account\u0026#39; --output text)\u0026#34; else echo \u0026#34;❌ Chưa cấu hình\u0026#34; fi # Kiểm tra ECR access echo -n \u0026#34;ECR Access: \u0026#34; if aws ecr describe-repositories --repository-names lambda-workshop/product-api \u0026amp;\u0026gt; /dev/null; then echo \u0026#34;✅ Repository đã tạo\u0026#34; else echo \u0026#34;❌ Repository chưa tạo\u0026#34; fi echo \u0026#34;=== Hoàn thành kiểm tra ===\u0026#34; EOF chmod +x scripts/check-environment.sh 2. Chạy kiểm tra 1 ./scripts/check-environment.sh Tạo file cấu hình 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 cat \u0026gt; config.json \u0026lt;\u0026lt; EOF { \u0026#34;aws\u0026#34;: { \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;account_id\u0026#34;: \u0026#34;$(aws sts get-caller-identity --query Account --output text)\u0026#34; }, \u0026#34;ecr\u0026#34;: { \u0026#34;registry\u0026#34;: \u0026#34;$ECR_REGISTRY\u0026#34;, \u0026#34;repository\u0026#34;: \u0026#34;$ECR_REGISTRY/lambda-workshop/product-api\u0026#34; }, \u0026#34;lambda\u0026#34;: { \u0026#34;function_name\u0026#34;: \u0026#34;workshop-product-api\u0026#34;, \u0026#34;memory_size\u0026#34;: 512, \u0026#34;timeout\u0026#34;: 30, \u0026#34;Kiến trúc\u0026#34;: \u0026#34;x86_64\u0026#34; } } EOF Kết luận Bạn đã ho à n th à nh vi ệ c thiết lập môi trường phát triển với:\n✅ Docker để build Container Images ✅ AWS CLI để t ươ ng t á c với AWS services ✅ Python 3.11 runtime environment ✅ ECR repository để l ư u tr ữ images ✅ C ấ u tr ú c project organized Hãy chạy ./scripts/check-environment.sh để đảm bảo tất cả đã được cài đặt đúng cách trước khi tiếp tục.\nTiếp theo, chúng ta sẽ b ắ t đầ u tạo ứng dụng mẫu và build Container Images.\n"
},
{
	"uri": "//localhost:1313/vi/3-container-optimization/",
	"title": "Tối ưu hóa Container Image",
	"tags": [],
	"description": "",
	"content": "Tối ưu hóa Container Image Tổng quan Trong phần này, bạn sẽ học các kỹ thuật nâng cao để tối ưu hóa Lambda Container Images nhằm đạt hiệu suất tối đa. Chúng ta sẽ tập trung vào việc giảm thời gian Cold Start, tối thiểu hóa kích thước image, và tối ưu hóa hiệu suất runtime thông qua các bài tập thực hành.\nNhững gì bạn sẽ xây dựng Ứng dụng mẫu: API sản phẩm hoàn chỉnh với các thao tác CRUD Container Images: Cả phiên bản cơ bản và tối ưu hóa sử dụng multi-stage builds Lambda Functions: Triển khai và so sánh hiệu suất giữa các tối ưu hóa khác nhau Monitoring: Thiết lập theo dõi hiệu suất toàn diện Mục tiêu học tập Tạo ứng dụng Lambda container sẵn sàng cho môi trường sản xuất Triển khai multi-stage Docker builds để tối ưu hóa Triển khai và kiểm thử Lambda functions từ Container Images So sánh các chỉ số hiệu suất giữa images tối ưu hóa và cơ bản Thiết lập monitoring và cảnh báo cho Lambda functions dựa trên container Các phần thực hành 3.1 Tạo ứng dụng mẫu Xây dựng ứng dụng Product API hoàn chỉnh với:\nLambda function handler với routing phù hợp Product service với các thao tác CRUD Tích hợp các chỉ số hiệu suất Khả năng kiểm thử cục bộ 3.2 Xây dựng Container Images Tạo Docker containers tối ưu hóa:\nDockerfile cơ bản cho triển khai ban đầu Dockerfile tối ưu hóa multi-stage Xây dựng và đẩy images lên Amazon ECR So sánh kích thước images và kiểm thử cục bộ 3.3 Tạo Lambda Functions Triển khai Lambda functions từ containers:\nTạo IAM roles và quyền Triển khai cả phiên bản cơ bản và tối ưu hóa Thiết lập tích hợp API Gateway 3.4 Security Best Practices Triển khai các thực hành bảo mật:\nContainer image scanning với Trivy Least privilege IAM policies Secrets management Network security 3.5 Testing \u0026amp; Quality Assurance Thiết lập testing toàn diện:\nUnit tests cho business logic Integration tests cho Lambda functions Performance testing và benchmarking Automated quality gates Kiến trúc tổng quan ┌─────────────────────────────────────────────────────────────────┐ │ Development Environment │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ Source Code │ │ Dockerfile │ │ Tests │ │ │ └─────────────┘ └─────────────┘ └─────────────┘ │ └─────────────────────┬───────────────────────────────────────────┘ │ Build \u0026amp; Push ┌─────────────────────▼───────────────────────────────────────────┐ │ Amazon ECR Repository │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ Base Image │ │ Optimized │ │ Security │ │ │ │ (Large) │ │ Image │ │ Scanned │ │ │ └─────────────┘ └─────────────┘ └─────────────┘ │ └─────────────────────┬───────────────────────────────────────────┘ │ Deploy ┌─────────────────────▼───────────────────────────────────────────┐ │ AWS Lambda Functions │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ Product API │ │ Monitoring │ │ Performance │ │ │ │ (Container) │ │ Enabled │ │ Optimized │ │ │ └─────────────┘ └─────────────┘ └─────────────┘ │ └─────────────────────────────────────────────────────────────────┘ Kết quả mong đợi Sau khi hoàn thành phần này:\n✅ Ứng dụng Lambda container hoạt động hoàn chỉnh ✅ Container images được tối ưu hóa (giảm 30-50% kích thước) ✅ Cold start times được cải thiện đáng kể ✅ Security scanning và best practices được triển khai ✅ Comprehensive testing suite ✅ Performance monitoring được thiết lập Metrics mục tiêu Metric Before After Target Image Size 500MB+ \u0026lt;250MB 50% reduction Cold Start 3-5s \u0026lt;1.5s 70% improvement Build Time 5-10min \u0026lt;3min 50% faster Security Score Unknown A+ Zero critical vulnerabilities Bắt đầu với: Tạo ứng dụng mẫu\n"
},
{
	"uri": "//localhost:1313/vi/3-container-optimization/3.4-security-practices/",
	"title": "Bảo mật Thực hành tốt nhất",
	"tags": [],
	"description": "",
	"content": "Bảo mật Thực hành tốt nhất Tổng quan Trong phần này, chúng ta sẽ implement các Bảo mật Thực hành tốt nhất cho Lambda Container Images để đả m b ả o ứng dụng an to à n trong M ô i tr ườ ng sản xuất.\nContainer Image Bảo mật 1. Vulnerability Scanning 1 2 3 4 5 6 7 8 9 10 cd ~/lambda-container-workshop # Cài đặt Trivy để scan vulnerabilities curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin # Scan container image ECR_REGISTRY=$(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4) IMAGE=\u0026#34;${ECR_REGISTRY}/lambda-workshop/product-api:optimized-latest\u0026#34; trivy image $IMAGE --format table --severity HIGH,CRITICAL 2. Multi-stage Dockerfile với Bảo mật focus 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 cat \u0026gt; docker/secure/Dockerfile \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Build stage với minimal tools FROM public.ecr.aws/lambda/python:3.11 as builder # Create non-root user RUN groupadd -r appgroup \u0026amp;\u0026amp; useradd -r -g appgroup appuser # Install only necessary build dependencies RUN yum update -y \u0026amp;\u0026amp; \\ yum install -y gcc python3-devel \u0026amp;\u0026amp; \\ yum clean all \u0026amp;\u0026amp; \\ rm -rf /var/cache/yum # Copy requirements và install COPY requirements.txt . RUN pip install --no-cache-dir --target /opt/python -r requirements.txt # Remove unnecessary files và potential Bảo mật risks RUN find /opt/python -name \u0026#34;*.pyc\u0026#34; -delete \u0026amp;\u0026amp; \\ find /opt/python -name \u0026#34;__pycache__\u0026#34; -type d -exec rm -rf {} + \u0026amp;\u0026amp; \\ find /opt/python -name \u0026#34;*.so\u0026#34; -exec strip {} \\; 2\u0026gt;/dev/null || true \u0026amp;\u0026amp; \\ find /opt/python -name \u0026#34;test*\u0026#34; -type d -exec rm -rf {} + 2\u0026gt;/dev/null || true # Môi trường sản xuất stage FROM public.ecr.aws/lambda/python:3.11 # Copy dependencies from builder COPY --from=builder /opt/python ${LAMBDA_TASK_ROOT}/ # Copy application code với proper ownership COPY --chown=nobody:nobody lambda_function.py ${LAMBDA_TASK_ROOT}/ COPY --chown=nobody:nobody src/ ${LAMBDA_TASK_ROOT}/src/ # Set Bảo mật-focused environment variables ENV PYTHONPATH=\u0026#34;${LAMBDA_TASK_ROOT}/src:${PYTHONPATH}\u0026#34; ENV PYTHONDONTWRITEBYTECODE=1 ENV PYTHONUNBUFFERED=1 ENV PYTHONHASHSEED=random # Remove potential Bảo mật risks RUN rm -rf /tmp/* /var/tmp/* \u0026amp;\u0026amp; \\ find ${LAMBDA_TASK_ROOT} -name \u0026#34;*.py\u0026#34; -exec chmod 644 {} \\; \u0026amp;\u0026amp; \\ find ${LAMBDA_TASK_ROOT} -type d -exec chmod 755 {} \\; # Health check HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\ CMD python -c \u0026#34;import lambda_function; print(\u0026#39;OK\u0026#39;)\u0026#34; || exit 1 CMD [\u0026#34;lambda_function.lambda_handler\u0026#34;] EOF 3. Secrets Management 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 # Tạo AWS Secrets Manager secret aws secretsmanager create-secret \\ --name \u0026#34;lambda-workshop/database\u0026#34; \\ --description \u0026#34;Database credentials for Lambda workshop\u0026#34; \\ --secret-string \u0026#39;{ \u0026#34;username\u0026#34;: \u0026#34;workshop_user\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;secure_password_123\u0026#34;, \u0026#34;host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;port\u0026#34;: 5432, \u0026#34;database\u0026#34;: \u0026#34;workshop_db\u0026#34; }\u0026#39; # Update Lambda function để sử dụng secrets cat \u0026gt; src/utils/secrets_manager.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import boto3 import json from functools import lru_cache import os class SecretsManager: def __init__(self): self.client = boto3.client(\u0026#39;secretsmanager\u0026#39;) @lru_cache(maxsize=10) def get_secret(self, secret_name: str) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;Get secret from AWS Secrets Manager with Bộ nhớ đệm (Caching)\u0026#34;\u0026#34;\u0026#34; try: response = self.client.get_secret_value(SecretId=secret_name) return json.loads(response[\u0026#39;SecretString\u0026#39;]) except Exception as e: print(f\u0026#34;Error retrieving secret {secret_name}: {e}\u0026#34;) return {} def get_database_config(self) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;Get database configuration from secrets\u0026#34;\u0026#34;\u0026#34; secret_name = os.environ.get(\u0026#39;DB_SECRET_NAME\u0026#39;, \u0026#39;lambda-workshop/database\u0026#39;) return self.get_secret(secret_name) # Global instance secrets_manager = SecretsManager() EOF IAM Bảo mật 1. Least Privilege IAM Policy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 cat \u0026gt; lambda-Bảo mật-policy.json \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:logs:*:*:*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;secretsmanager:GetSecretValue\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:secretsmanager:*:*:secret:lambda-workshop/*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;CloudWatch:PutMetricData\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;CloudWatch:namespace\u0026#34;: \u0026#34;Lambda/ContainerHiệu suất\u0026#34; } } } ] } EOF # Tạo policy aws iam create-policy \\ --policy-name lambda-workshop-Bảo mật-policy \\ --policy-document file://lambda-Bảo mật-policy.json # Attach to role ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text) aws iam attach-role-policy \\ --role-name lambda-container-workshop-role \\ --policy-arn \u0026#34;arn:aws:iam::${ACCOUNT_ID}:policy/lambda-workshop-Bảo mật-policy\u0026#34; 2. Environment Variables Bảo mật 1 2 3 4 5 6 7 8 9 # Update Lambda function với secure environment variables AWS Lambda update-function-configuration \\ --function-name workshop-product-api-optimized \\ --environment Variables=\u0026#39;{ \u0026#34;ENVIRONMENT\u0026#34;:\u0026#34;Môi trường sản xuất\u0026#34;, \u0026#34;LOG_LEVEL\u0026#34;:\u0026#34;INFO\u0026#34;, \u0026#34;DB_SECRET_NAME\u0026#34;:\u0026#34;lambda-workshop/database\u0026#34;, \u0026#34;ENCRYPTION_KEY_ID\u0026#34;:\u0026#34;alias/lambda-workshop-key\u0026#34; }\u0026#39; Runtime Bảo mật 1. Input Validation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 cat \u0026gt; src/utils/validators.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import re from typing import Any, Dict, List import bleach class InputValidator: \u0026#34;\u0026#34;\u0026#34;Input validation utilities\u0026#34;\u0026#34;\u0026#34; @staticmethod def validate_product_data(data: Dict[str, Any]) -\u0026gt; Dict[str, Any]: \u0026#34;\u0026#34;\u0026#34;Validate product data input\u0026#34;\u0026#34;\u0026#34; errors = [] # Name validation if \u0026#39;name\u0026#39; not in data or not data[\u0026#39;name\u0026#39;]: errors.append(\u0026#34;Product name is required\u0026#34;) elif len(data[\u0026#39;name\u0026#39;]) \u0026gt; 100: errors.append(\u0026#34;Product name too long (max 100 characters)\u0026#34;) else: # Sanitize HTML data[\u0026#39;name\u0026#39;] = bleach.clean(data[\u0026#39;name\u0026#39;]) # Price validation if \u0026#39;price\u0026#39; not in data: errors.append(\u0026#34;Price is required\u0026#34;) else: try: price = float(data[\u0026#39;price\u0026#39;]) if price \u0026lt; 0: errors.append(\u0026#34;Price must be positive\u0026#34;) elif price \u0026gt; 999999: errors.append(\u0026#34;Price too high\u0026#34;) data[\u0026#39;price\u0026#39;] = price except (ValueError, TypeError): errors.append(\u0026#34;Invalid price format\u0026#34;) # Category validation if \u0026#39;category\u0026#39; in data: if len(data[\u0026#39;category\u0026#39;]) \u0026gt; 50: errors.append(\u0026#34;Category name too long\u0026#34;) else: data[\u0026#39;category\u0026#39;] = bleach.clean(data[\u0026#39;category\u0026#39;]) # Description validation if \u0026#39;description\u0026#39; in data: if len(data[\u0026#39;description\u0026#39;]) \u0026gt; 1000: errors.append(\u0026#34;Description too long\u0026#34;) else: data[\u0026#39;description\u0026#39;] = bleach.clean(data[\u0026#39;description\u0026#39;]) if errors: raise ValueError(f\u0026#34;Validation errors: {\u0026#39;, \u0026#39;.join(errors)}\u0026#34;) return data @staticmethod def validate_id(product_id: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Validate product ID\u0026#34;\u0026#34;\u0026#34; if not product_id: raise ValueError(\u0026#34;Product ID is required\u0026#34;) # Check for SQL injection patterns if re.search(r\u0026#39;[;\\\u0026#39;\u0026#34;\\\\]\u0026#39;, product_id): raise ValueError(\u0026#34;Invalid product ID format\u0026#34;) if len(product_id) \u0026gt; 50: raise ValueError(\u0026#34;Product ID too long\u0026#34;) return product_id.strip() # Update requirements.txt echo \u0026#34;bleach==6.1.0\u0026#34; \u0026gt;\u0026gt; requirements.txt EOF 2. Logging và monitoring Bảo mật 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 cat \u0026gt; src/utils/security_logger.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import json import logging from datetime import datetime from typing import Dict, Any class SecurityLogger: \u0026#34;\u0026#34;\u0026#34;Bảo mật-focused logging\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.logger = logging.getLogger(\u0026#39;Bảo mật\u0026#39;) self.logger.setLevel(logging.INFO) def log_security_event(self, event_type: str, details: Dict[str, Any], severity: str = \u0026#39;INFO\u0026#39;): \u0026#34;\u0026#34;\u0026#34;Log Bảo mật events\u0026#34;\u0026#34;\u0026#34; event = { \u0026#39;timestamp\u0026#39;: datetime.utcnow().isoformat(), \u0026#39;event_type\u0026#39;: event_type, \u0026#39;severity\u0026#39;: severity, \u0026#39;details\u0026#39;: self._sanitize_details(details) } if severity == \u0026#39;CRITICAL\u0026#39;: self.logger.critical(json.dumps(event)) elif severity == \u0026#39;WARNING\u0026#39;: self.logger.warning(json.dumps(event)) else: self.logger.info(json.dumps(event)) def log_access_attempt(self, method: str, path: str, ip: str = None): \u0026#34;\u0026#34;\u0026#34;Log API access attempts\u0026#34;\u0026#34;\u0026#34; self.log_security_event(\u0026#39;api_access\u0026#39;, { \u0026#39;method\u0026#39;: method, \u0026#39;path\u0026#39;: path, \u0026#39;source_ip\u0026#39;: ip }) def log_validation_error(self, error: str, input_data: Dict[str, Any]): \u0026#34;\u0026#34;\u0026#34;Log input validation errors\u0026#34;\u0026#34;\u0026#34; self.log_security_event(\u0026#39;validation_error\u0026#39;, { \u0026#39;error\u0026#39;: error, \u0026#39;input_size\u0026#39;: len(str(input_data)) }, \u0026#39;WARNING\u0026#39;) def _sanitize_details(self, details: Dict[str, Any]) -\u0026gt; Dict[str, Any]: \u0026#34;\u0026#34;\u0026#34;Remove sensitive information from logs\u0026#34;\u0026#34;\u0026#34; sanitized = {} sensitive_keys = [\u0026#39;password\u0026#39;, \u0026#39;token\u0026#39;, \u0026#39;key\u0026#39;, \u0026#39;secret\u0026#39;] for key, value in details.items(): if any(sensitive in key.lower() for sensitive in sensitive_keys): sanitized[key] = \u0026#39;[REDACTED]\u0026#39; else: sanitized[key] = value return sanitized # Global instance security_logger = SecurityLogger() EOF Bảo mật Kiểm thử 1. Bảo mật test script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 cat \u0026gt; scripts/Bảo mật-test.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash FUNCTION_NAME=${1:-\u0026#34;workshop-product-api-optimized\u0026#34;} echo \u0026#34;=== Bảo mật Kiểm thử for $FUNCTION_NAME ===\u0026#34; # Test 1: SQL Injection attempts echo \u0026#34;1. Kiểm thử SQL Injection protection...\u0026#34; AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#39;{ \u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;:\u0026#34;/products/1; DROP TABLE products;--\u0026#34;, \u0026#34;pathParameters\u0026#34;:{\u0026#34;id\u0026#34;:\u0026#34;1; DROP TABLE products;--\u0026#34;} }\u0026#39; \\ response.json echo \u0026#34;Response:\u0026#34; cat response.json | jq . echo # Test 2: XSS attempts echo \u0026#34;2. Kiểm thử XSS protection...\u0026#34; AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#39;{ \u0026#34;httpMethod\u0026#34;:\u0026#34;POST\u0026#34;, \u0026#34;path\u0026#34;:\u0026#34;/products\u0026#34;, \u0026#34;body\u0026#34;:\u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\\\u0026#34;,\\\u0026#34;price\\\u0026#34;:99.99,\\\u0026#34;category\\\u0026#34;:\\\u0026#34;Test\\\u0026#34;}\u0026#34; }\u0026#39; \\ response.json echo \u0026#34;Response:\u0026#34; cat response.json | jq . echo # Test 3: Large payload echo \u0026#34;3. Kiểm thử large payload handling...\u0026#34; LARGE_PAYLOAD=$(python3 -c \u0026#34;print(\u0026#39;A\u0026#39; * 10000)\u0026#34;) AWS Lambda invoke \\ --function-name $FUNCTION_NAME \\ --payload \u0026#34;{ \\\u0026#34;httpMethod\\\u0026#34;:\\\u0026#34;POST\\\u0026#34;, \\\u0026#34;path\\\u0026#34;:\\\u0026#34;/products\\\u0026#34;, \\\u0026#34;body\\\u0026#34;:\\\u0026#34;{\\\\\\\u0026#34;name\\\\\\\u0026#34;:\\\\\\\u0026#34;$LARGE_PAYLOAD\\\\\\\u0026#34;,\\\\\\\u0026#34;price\\\\\\\u0026#34;:99.99}\\\u0026#34; }\u0026#34; \\ response.json echo \u0026#34;Response:\u0026#34; cat response.json | jq . echo # Dọn dẹp rm -f response.json echo \u0026#34;✅ Bảo mật tests completed!\u0026#34; EOF chmod +x scripts/Bảo mật-test.sh 2. Chạy Bảo mật tests 1 2 3 4 5 # Run Bảo mật tests ./scripts/Bảo mật-test.sh workshop-product-api-optimized # Scan container image for vulnerabilities trivy image $(grep -o \u0026#39;\u0026#34;registry\u0026#34;: \u0026#34;[^\u0026#34;]*\u0026#39; config.json | cut -d\u0026#39;\u0026#34;\u0026#39; -f4)/lambda-workshop/product-api:optimized-latest Bảo mật monitoring 1. CloudWatch Alarms cho Bảo mật 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 cat \u0026gt; scripts/setup-Bảo mật-alarms.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash FUNCTION_NAME=\u0026#34;workshop-product-api-optimized\u0026#34; SNS_TOPIC_ARN=\u0026#34;arn:aws:sns:us-east-1:$(aws sts get-caller-identity --query Account --output text):Bảo mật-alerts\u0026#34; # Create SNS topic for Bảo mật alerts aws sns create-topic --name Bảo mật-alerts # High error rate alarm aws CloudWatch put-metric-alarm \\ --alarm-name \u0026#34;Bảo mật-${FUNCTION_NAME}-HighErrorRate\u0026#34; \\ --alarm-description \u0026#34;High error rate detected\u0026#34; \\ --metric-name Errors \\ --namespace AWS/Lambda \\ --statistic Sum \\ --period 300 \\ --threshold 10 \\ --comparison-operator GreaterThanThreshold \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --evaluation-periods 2 \\ --alarm-actions $SNS_TOPIC_ARN # Unusual invocation pattern aws CloudWatch put-metric-alarm \\ --alarm-name \u0026#34;Bảo mật-${FUNCTION_NAME}-UnusualInvocations\u0026#34; \\ --alarm-description \u0026#34;Unusual invocation pattern detected\u0026#34; \\ --metric-name Invocations \\ --namespace AWS/Lambda \\ --statistic Sum \\ --period 300 \\ --threshold 1000 \\ --comparison-operator GreaterThanThreshold \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME \\ --evaluation-periods 1 \\ --alarm-actions $SNS_TOPIC_ARN echo \u0026#34;✅ Bảo mật alarms created!\u0026#34; EOF chmod +x scripts/setup-Bảo mật-alarms.sh ./scripts/setup-Bảo mật-alarms.sh Kết luận Bạn đã implement các Bảo mật Thực hành tốt nhất:\n✅ Container vulnerability scanning ✅ Secure Dockerfile với least privilege ✅ Secrets management với AWS Secrets Manager ✅ Input validation và sanitization ✅ Bảo mật logging và giám sát (Monitoring) ✅ Bảo mật Kiểm thử automation ✅ CloudWatch Bảo mật alarms Bảo mật Checklist:\nRegular vulnerability scanning Rotate secrets periodically Monitor Bảo mật logs Update dependencies regularly Review IAM permissions quarterly C á c practices này đả m b ả o Lambda container applications c ủ a bạn an to à n trong M ô i tr ườ ng sản xuất environment.\n"
},
{
	"uri": "//localhost:1313/vi/4-monitoring/",
	"title": "giám sát &amp; Ph â n t í ch hiệu suất",
	"tags": [],
	"description": "",
	"content": "Giám sát \u0026amp; Phân tích hiệu suất Tổng quan Trong phần này, bạn sẽ triển khai giám sát và phân tích hiệu suất toàn diện cho các Lambda container functions. Ch ú ng ta sẽ thiết lập theo d õ i hiệu suất th ờ i gian th ự c, phân tích bộnh ớ, c ả nh b á o t ự độ ng, và tiến h à nh kiểm thử hiệu suất k ỹ l ưỡ ng để đ o l ườ ng hi ệ u qu ả c ủ a các t ố i ư u h ó a.\nNhững gì bạn sẽ học Kiểm thử hiệu suất: Thiết lập công cụ Kiểm thử t ả i (Load Kiểm thử) và Đá nh gi á hiệu suất (Benchmarking) Ph â n t í ch Cold Start: Đo l ườ ng và so s á nh hiệu suất Cold Start T í ch h ợ p CloudWatch: Tri ể n khai custom metrics và giám sát So s á nh hiệu suất: So s á nh hiệu suất container t ố i ư u h ó a vs c ơ b ả n B á o c á o t ự độ ng: Tạo b á o c á o hiệu suất toàn diện Các phần thực hành 4.1 Triển khai và kiểm thử hiệu suất Kiểm thử hiệu suất toàn diện bao g ồ m:\nThiết lập Kiểm thử t ả i (Load Kiểm thử) với Artillery Đá nh gi á hiệu suất (Benchmarking) Cold Start So s á nh hiệu suất function Ph â n t í ch CloudWatch metrics B á o c á o hiệu suất t ự độ ng Giám sát nâng cao với CloudWatch 1. Triển khai Custom Metrics Tạo class custom metrics để theo d õ i hiệu suất chi tiết:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 # src/monitoring/custom_metrics.py import boto3 import time import json from datetime import datetime from functools import wraps class Hiệu suấtMetrics: def __init__(self): self.CloudWatch = boto3.client(\u0026#39;CloudWatch\u0026#39;) self.namespace = \u0026#39;Lambda/ContainerHiệu suất\u0026#39; self.function_name = os.environ.get(\u0026#39;AWS_LAMBDA_FUNCTION_NAME\u0026#39;, \u0026#39;unknown\u0026#39;) def put_metric(self, metric_name, value, unit=\u0026#39;Count\u0026#39;, dimensions=None): \u0026#34;\u0026#34;\u0026#34;Gửi custom metric lên CloudWatch\u0026#34;\u0026#34;\u0026#34; try: dimensions = dimensions or [] dimensions.append({ \u0026#39;Name\u0026#39;: \u0026#39;FunctionName\u0026#39;, \u0026#39;Value\u0026#39;: self.function_name }) self.CloudWatch.put_metric_data( Namespace=self.namespace, MetricData=[ { \u0026#39;MetricName\u0026#39;: metric_name, \u0026#39;Value\u0026#39;: value, \u0026#39;Unit\u0026#39;: unit, \u0026#39;Dimensions\u0026#39;: dimensions, \u0026#39;Timestamp\u0026#39;: datetime.utcnow() } ] ) except Exception as e: print(f\u0026#34;Không thể gửi metric {metric_name}: {e}\u0026#34;) def track_cold_start(self): \u0026#34;\u0026#34;\u0026#34;Theo dõi Cold Start occurrence\u0026#34;\u0026#34;\u0026#34; # Kiểm tra xem đây có phải Cold Start không if not hasattr(self, \u0026#39;_warm_start\u0026#39;): self.put_metric(\u0026#39;ColdStart\u0026#39;, 1) self._warm_start = True else: self.put_metric(\u0026#39;WarmStart\u0026#39;, 1) def track_memory_usage(self): \u0026#34;\u0026#34;\u0026#34;Theo dõi việc sử dụng bộ nhớ\u0026#34;\u0026#34;\u0026#34; import psutil process = psutil.Process() memory_mb = process.memory_info().rss / 1024 / 1024 self.put_metric(\u0026#39;MemoryUsageMB\u0026#39;, memory_mb, \u0026#39;None\u0026#39;) # Tính toán hiệu quả bộ nhớ allocated_mb = int(os.environ.get(\u0026#39;AWS_LAMBDA_FUNCTION_MEMORY_SIZE\u0026#39;, 128)) efficiency = (memory_mb / allocated_mb) * 100 self.put_metric(\u0026#39;MemoryEfficiency\u0026#39;, efficiency, \u0026#39;Percent\u0026#39;) def track_execution_time(self, start_time, operation_name): \u0026#34;\u0026#34;\u0026#34;Theo dõi thời gian thực thi operation\u0026#34;\u0026#34;\u0026#34; duration_ms = (time.time() - start_time) * 1000 self.put_metric(f\u0026#39;{operation_name}Duration\u0026#39;, duration_ms, \u0026#39;Milliseconds\u0026#39;) return duration_ms # Global metrics instance metrics = Hiệu suấtMetrics() def monitor_hiệu suất(operation_name): \u0026#34;\u0026#34;\u0026#34;Decorator để giám sát hiệu suất function\u0026#34;\u0026#34;\u0026#34; def decorator(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() try: result = func(*args, **kwargs) metrics.put_metric(f\u0026#39;{operation_name}Success\u0026#39;, 1) return result except Exception as e: metrics.put_metric(f\u0026#39;{operation_name}Error\u0026#39;, 1) raise finally: metrics.track_execution_time(start_time, operation_name) return wrapper return decorator 2. Lambda Handler nâng cao với giám sát 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 # lambda_function.py (Nâng cao với monitoring) import json import os import time from src.monitoring.custom_metrics import metrics, monitor_hiệu suất from src.optimizations.memory_profiler import profiler def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Lambda handler nâng cao với giám sát toàn diện\u0026#34;\u0026#34;\u0026#34; start_time = time.time() # Theo dõi cold/warm start metrics.track_cold_start() profiler.checkpoint(\u0026#39;handler_start\u0026#39;) try: # Theo dõi việc sử dụng bộ nhớ lúc bắt đầu metrics.track_memory_usage() # Parse request http_method = event.get(\u0026#39;httpMethod\u0026#39;, \u0026#39;GET\u0026#39;) path = event.get(\u0026#39;path\u0026#39;, \u0026#39;/\u0026#39;) profiler.checkpoint(\u0026#39;request_parsed\u0026#39;) # Route và xử lý request if path.startswith(\u0026#39;/products\u0026#39;): response = handle_products_monitored(http_method, path, event.get(\u0026#39;body\u0026#39;)) elif path.startswith(\u0026#39;/orders\u0026#39;): response = handle_orders_monitored(http_method, path, event.get(\u0026#39;body\u0026#39;)) else: response = { \u0026#39;statusCode\u0026#39;: 404, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: \u0026#39;Not found\u0026#39;}) } profiler.checkpoint(\u0026#39;request_processed\u0026#39;) # Theo dõi việc sử dụng bộ nhớ cuối cùng metrics.track_memory_usage() # Thêm hiệu suất headers total_duration = (time.time() - start_time) * 1000 response[\u0026#39;headers\u0026#39;] = response.get(\u0026#39;headers\u0026#39;, {}) response[\u0026#39;headers\u0026#39;].update({ \u0026#39;X-Execution-Time\u0026#39;: f\u0026#39;{total_duration:.2f}ms\u0026#39;, \u0026#39;X-Memory-Report\u0026#39;: json.dumps(profiler.get_report()), \u0026#39;X-Function-Version\u0026#39;: context.function_version, \u0026#39;X-Request-Id\u0026#39;: context.aws_request_id }) # Theo dõi thành công tổng thể metrics.put_metric(\u0026#39;RequestSuccess\u0026#39;, 1) metrics.track_execution_time(start_time, \u0026#39;TotalRequest\u0026#39;) return response except Exception as e: profiler.checkpoint(\u0026#39;error_occurred\u0026#39;) metrics.put_metric(\u0026#39;RequestError\u0026#39;, 1) # Theo dõi chi tiết lỗi error_type = type(e).__name__ metrics.put_metric(f\u0026#39;Error_{error_type}\u0026#39;, 1) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: str(e)}), \u0026#39;headers\u0026#39;: { \u0026#39;X-Execution-Time\u0026#39;: f\u0026#39;{(time.time() - start_time) * 1000:.2f}ms\u0026#39;, \u0026#39;X-Memory-Report\u0026#39;: json.dumps(profiler.get_report()) } } @monitor_hiệu suất(\u0026#39;ProductAPI\u0026#39;) def handle_products_monitored(method, path, body): \u0026#34;\u0026#34;\u0026#34;Product handler với monitoring\u0026#34;\u0026#34;\u0026#34; # Triển khai với monitoring pass @monitor_hiệu suất(\u0026#39;OrderAPI\u0026#39;) def handle_orders_monitored(method, path, body): \u0026#34;\u0026#34;\u0026#34;Order handler với monitoring\u0026#34;\u0026#34;\u0026#34; # Triển khai với monitoring pass X-Ray Distributed Tracing 1. Tích hợp X-Ray 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # src/monitoring/xray_tracing.py from aws_xray_sdk.core import xray_recorder, patch_all from aws_xray_sdk.core.context import Context import boto3 # Patch AWS SDK calls patch_all() class XRayTracing: def __init__(self): self.recorder = xray_recorder def trace_subsegment(self, name): \u0026#34;\u0026#34;\u0026#34;Tạo subsegment để tracing chi tiết\u0026#34;\u0026#34;\u0026#34; return self.recorder.in_subsegment(name) def add_annotation(self, key, value): \u0026#34;\u0026#34;\u0026#34;Thêm annotation vào segment hiện tại\u0026#34;\u0026#34;\u0026#34; try: self.recorder.current_subsegment().add_annotation(key, value) except: pass # Bỏ qua nếu không có active segment def add_metadata(self, namespace, data): \u0026#34;\u0026#34;\u0026#34;Thêm metadata vào segment hiện tại\u0026#34;\u0026#34;\u0026#34; try: self.recorder.current_subsegment().add_metadata(namespace, data) except: pass # Global tracer instance tracer = XRayTracing() # Handler nâng cao với X-Ray tracing def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Lambda handler với X-Ray tracing\u0026#34;\u0026#34;\u0026#34; # Thêm annotations để filtering tracer.add_annotation(\u0026#39;function_name\u0026#39;, context.function_name) tracer.add_annotation(\u0026#39;function_version\u0026#39;, context.function_version) tracer.add_annotation(\u0026#39;memory_size\u0026#39;, context.memory_limit_in_mb) # Thêm request metadata tracer.add_metadata(\u0026#39;request\u0026#39;, { \u0026#39;method\u0026#39;: event.get(\u0026#39;httpMethod\u0026#39;), \u0026#39;path\u0026#39;: event.get(\u0026#39;path\u0026#39;), \u0026#39;user_agent\u0026#39;: event.get(\u0026#39;headers\u0026#39;, {}).get(\u0026#39;User-Agent\u0026#39;), \u0026#39;source_ip\u0026#39;: event.get(\u0026#39;requestContext\u0026#39;, {}).get(\u0026#39;identity\u0026#39;, {}).get(\u0026#39;sourceIp\u0026#39;) }) with tracer.trace_subsegment(\u0026#39;request_processing\u0026#39;): # Logic handler hiện tại của bạn response = process_request(event, context) # Thêm response metadata tracer.add_metadata(\u0026#39;response\u0026#39;, { \u0026#39;status_code\u0026#39;: response.get(\u0026#39;statusCode\u0026#39;), \u0026#39;response_size\u0026#39;: len(response.get(\u0026#39;body\u0026#39;, \u0026#39;\u0026#39;)) }) return response 2. Database Query Tracing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # src/monitoring/database_tracing.py import boto3 from aws_xray_sdk.core import xray_recorder class TracedDynamoDB: def __init__(self): self.DynamoDB = boto3.resource(\u0026#39;DynamoDB\u0026#39;) def get_item_traced(self, table_name, key): \u0026#34;\u0026#34;\u0026#34;Get item với X-Ray tracing\u0026#34;\u0026#34;\u0026#34; with xray_recorder.in_subsegment(f\u0026#39;dynamodb_get_{table_name}\u0026#39;): table = self.DynamoDB.Table(table_name) # Thêm annotations xray_recorder.current_subsegment().add_annotation(\u0026#39;table_name\u0026#39;, table_name) xray_recorder.current_subsegment().add_annotation(\u0026#39;operation\u0026#39;, \u0026#39;get_item\u0026#39;) response = table.get_item(Key=key) # Thêm metadata xray_recorder.current_subsegment().add_metadata(\u0026#39;DynamoDB\u0026#39;, { \u0026#39;consumed_capacity\u0026#39;: response.get(\u0026#39;ConsumedCapacity\u0026#39;), \u0026#39;item_found\u0026#39;: \u0026#39;Item\u0026#39; in response }) return response def scan_traced(self, table_name, **kwargs): \u0026#34;\u0026#34;\u0026#34;Scan table với X-Ray tracing\u0026#34;\u0026#34;\u0026#34; with xray_recorder.in_subsegment(f\u0026#39;dynamodb_scan_{table_name}\u0026#39;): table = self.DynamoDB.Table(table_name) xray_recorder.current_subsegment().add_annotation(\u0026#39;table_name\u0026#39;, table_name) xray_recorder.current_subsegment().add_annotation(\u0026#39;operation\u0026#39;, \u0026#39;scan\u0026#39;) response = table.scan(**kwargs) xray_recorder.current_subsegment().add_metadata(\u0026#39;DynamoDB\u0026#39;, { \u0026#39;scanned_count\u0026#39;: response.get(\u0026#39;ScannedCount\u0026#39;), \u0026#39;item_count\u0026#39;: response.get(\u0026#39;Count\u0026#39;), \u0026#39;consumed_capacity\u0026#39;: response.get(\u0026#39;ConsumedCapacity\u0026#39;) }) return response # Global traced DynamoDB instance traced_db = TracedDynamoDB() Dashboard hiệu suất thời gian thực 1. Cấu hình CloudWatch Dashboard Tạo monitoring/dashboard.json:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 { \u0026#34;widgets\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;x\u0026#34;: 0, \u0026#34;y\u0026#34;: 0, \u0026#34;width\u0026#34;: 12, \u0026#34;height\u0026#34;: 6, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [\u0026#34;Lambda/ContainerHiệu suất\u0026#34;, \u0026#34;ColdStart\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;workshop-product-api\u0026#34;], [\u0026#34;.\u0026#34;, \u0026#34;WarmStart\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;], [\u0026#34;AWS/Lambda\u0026#34;, \u0026#34;Duration\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;], [\u0026#34;.\u0026#34;, \u0026#34;Errors\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;] ], \u0026#34;period\u0026#34;: 300, \u0026#34;stat\u0026#34;: \u0026#34;Sum\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Tổng quan hiệu suất Lambda\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;x\u0026#34;: 12, \u0026#34;y\u0026#34;: 0, \u0026#34;width\u0026#34;: 12, \u0026#34;height\u0026#34;: 6, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [\u0026#34;Lambda/ContainerHiệu suất\u0026#34;, \u0026#34;MemoryUsageMB\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;workshop-product-api\u0026#34;], [\u0026#34;.\u0026#34;, \u0026#34;MemoryEfficiency\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;] ], \u0026#34;period\u0026#34;: 300, \u0026#34;stat\u0026#34;: \u0026#34;Average\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Sử dụng bộ nhớ\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;metric\u0026#34;, \u0026#34;x\u0026#34;: 0, \u0026#34;y\u0026#34;: 6, \u0026#34;width\u0026#34;: 24, \u0026#34;height\u0026#34;: 6, \u0026#34;properties\u0026#34;: { \u0026#34;metrics\u0026#34;: [ [\u0026#34;Lambda/ContainerHiệu suất\u0026#34;, \u0026#34;ProductAPIDuration\u0026#34;, \u0026#34;FunctionName\u0026#34;, \u0026#34;workshop-product-api\u0026#34;], [\u0026#34;.\u0026#34;, \u0026#34;OrderAPIDuration\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;], [\u0026#34;.\u0026#34;, \u0026#34;TotalRequestDuration\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;.\u0026#34;] ], \u0026#34;period\u0026#34;: 300, \u0026#34;stat\u0026#34;: \u0026#34;Average\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Phân tích thời gian phản hồi\u0026#34; } } ] } 2. Triển khai Dashboard 1 2 3 4 5 6 7 8 9 # scripts/deploy-dashboard.sh #!/bin/bash aws CloudWatch put-dashboard \\ --dashboard-name \u0026#34;Lambda-Container-Hiệu suất\u0026#34; \\ --dashboard-body file://monitoring/dashboard.json echo \u0026#34;Dashboard đã được triển khai thành công!\u0026#34; echo \u0026#34;Xem tại: https://console.aws.amazon.com/CloudWatch/home?region=${AWS_REGION}#dashboards:name=Lambda-Container-Hiệu suất\u0026#34; Cảnh báo tự động 1. CloudWatch Alarms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # scripts/create-alarms.sh #!/bin/bash FUNCTION_NAME=\u0026#34;workshop-product-api\u0026#34; SNS_TOPIC_ARN=\u0026#34;arn:aws:sns:${AWS_REGION}:${AWS_ACCOUNT_ID}:lambda-alerts\u0026#34; # Tạo SNS topic cho alerts aws sns create-topic --name lambda-alerts # Cảnh báo tỷ lệ Cold Start cao aws CloudWatch put-metric-alarm \\ --alarm-name \u0026#34;Lambda-High-Cold-Start-Rate\u0026#34; \\ --alarm-description \u0026#34;Cảnh báo khi tỷ lệ Cold Start cao\u0026#34; \\ --metric-name ColdStart \\ --namespace Lambda/ContainerHiệu suất \\ --statistic Sum \\ --period 300 \\ --threshold 10 \\ --comparison-operator GreaterThanThreshold \\ --evaluation-periods 2 \\ --alarm-actions ${SNS_TOPIC_ARN} \\ --dimensions Name=FunctionName,Value=${FUNCTION_NAME} # Cảnh báo tỷ lệ lỗi cao aws CloudWatch put-metric-alarm \\ --alarm-name \u0026#34;Lambda-High-Error-Rate\u0026#34; \\ --alarm-description \u0026#34;Cảnh báo khi tỷ lệ lỗi vượt quá 5%\u0026#34; \\ --metric-name Errors \\ --namespace AWS/Lambda \\ --statistic Sum \\ --period 300 \\ --threshold 5 \\ --comparison-operator GreaterThanThreshold \\ --evaluation-periods 1 \\ --alarm-actions ${SNS_TOPIC_ARN} \\ --dimensions Name=FunctionName,Value=${FUNCTION_NAME} # Cảnh báo thời gian thực thi cao aws CloudWatch put-metric-alarm \\ --alarm-name \u0026#34;Lambda-High-Duration\u0026#34; \\ --alarm-description \u0026#34;Cảnh báo khi thời gian thực thi trung bình vượt quá 5 giây\u0026#34; \\ --metric-name Duration \\ --namespace AWS/Lambda \\ --statistic Average \\ --period 300 \\ --threshold 5000 \\ --comparison-operator GreaterThanThreshold \\ --evaluation-periods 2 \\ --alarm-actions ${SNS_TOPIC_ARN} \\ --dimensions Name=FunctionName,Value=${FUNCTION_NAME} echo \u0026#34;Các cảnh báo đã được tạo thành công!\u0026#34; 2. Custom Alert Handler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # src/monitoring/alert_handler.py import json import boto3 from datetime import datetime, timedelta def process_cloudwatch_alarm(event, context): \u0026#34;\u0026#34;\u0026#34;Xử lý CloudWatch alarm và thực hiện hành động\u0026#34;\u0026#34;\u0026#34; # Parse SNS message message = json.loads(event[\u0026#39;Records\u0026#39;][0][\u0026#39;Sns\u0026#39;][\u0026#39;Message\u0026#39;]) alarm_name = message[\u0026#39;AlarmName\u0026#39;] new_state = message[\u0026#39;NewStateValue\u0026#39;] reason = message[\u0026#39;NewStateReason\u0026#39;] if new_state == \u0026#39;ALARM\u0026#39;: if \u0026#39;Cold-Start\u0026#39; in alarm_name: handle_cold_start_alarm(message) elif \u0026#39;Error-Rate\u0026#39; in alarm_name: handle_error_rate_alarm(message) elif \u0026#39;Duration\u0026#39; in alarm_name: handle_duration_alarm(message) return {\u0026#39;statusCode\u0026#39;: 200} def handle_cold_start_alarm(alarm_data): \u0026#34;\u0026#34;\u0026#34;Xử lý cảnh báo tỷ lệ Cold Start cao\u0026#34;\u0026#34;\u0026#34; function_name = extract_function_name(alarm_data) # Tăng provisioned concurrency lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) try: # Lấy provisioned concurrency hiện tại response = lambda_client.get_provisioned_concurrency_config( FunctionName=function_name ) current_concurrency = response[\u0026#39;AllocatedConcurrencyExecutions\u0026#39;] new_concurrency = min(current_concurrency + 10, 100) # Giới hạn tại 100 # Cập nhật provisioned concurrency lambda_client.put_provisioned_concurrency_config( FunctionName=function_name, ProvisionedConcurrencyExecutions=new_concurrency ) print(f\u0026#34;Đã tăng provisioned concurrency cho {function_name} từ {current_concurrency} lên {new_concurrency}\u0026#34;) except lambda_client.exceptions.ResourceNotFoundException: # Tạo provisioned concurrency nếu chưa tồn tại lambda_client.put_provisioned_concurrency_config( FunctionName=function_name, ProvisionedConcurrencyExecutions=10 ) print(f\u0026#34;Đã tạo provisioned concurrency cho {function_name} với 10 executions\u0026#34;) def handle_error_rate_alarm(alarm_data): \u0026#34;\u0026#34;\u0026#34;Xử lý cảnh báo tỷ lệ lỗi cao\u0026#34;\u0026#34;\u0026#34; # Có thể trigger rollback, gửi cảnh báo chi tiết, v.v. print(f\u0026#34;Phát hiện tỷ lệ lỗi cao: {alarm_data}\u0026#34;) def handle_duration_alarm(alarm_data): \u0026#34;\u0026#34;\u0026#34;Xử lý cảnh báo thời gian thực thi cao\u0026#34;\u0026#34;\u0026#34; # Có thể tăng memory allocation, trigger investigation, v.v. print(f\u0026#34;Phát hiện thời gian thực thi cao: {alarm_data}\u0026#34;) Kiểm thử và xác thực hiệu suất 1. Kiểm thử hiệu suất tự động 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 # tests/test_hiệu suất_monitoring.py import boto3 import json import time import pytest from concurrent.futures import ThreadPoolExecutor class TestHiệu suấtMonitoring: def setup_method(self): self.lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) self.CloudWatch = boto3.client(\u0026#39;CloudWatch\u0026#39;) self.function_name = \u0026#39;workshop-product-api\u0026#39; def test_cold_start_monitoring(self): \u0026#34;\u0026#34;\u0026#34;Kiểm thử việc giám sát Cold Start\u0026#34;\u0026#34;\u0026#34; # Buộc Cold Start self.lambda_client.update_function_configuration( FunctionName=self.function_name, Environment={\u0026#39;Variables\u0026#39;: {\u0026#39;FORCE_COLD\u0026#39;: str(time.time())}} ) time.sleep(5) # Invoke function response = self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({\u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;}) ) # Chờ metrics được publish time.sleep(60) # Kiểm tra xem Cold Start metric đã được publish chưa metrics = self.CloudWatch.get_metric_statistics( Namespace=\u0026#39;Lambda/ContainerHiệu suất\u0026#39;, MetricName=\u0026#39;ColdStart\u0026#39;, Dimensions=[{\u0026#39;Name\u0026#39;: \u0026#39;FunctionName\u0026#39;, \u0026#39;Value\u0026#39;: self.function_name}], StartTime=datetime.utcnow() - timedelta(minutes=5), EndTime=datetime.utcnow(), Period=300, Statistics=[\u0026#39;Sum\u0026#39;] ) assert len(metrics[\u0026#39;Datapoints\u0026#39;]) \u0026gt; 0, \u0026#34;Không tìm thấy Cold Start metric\u0026#34; assert metrics[\u0026#39;Datapoints\u0026#39;][0][\u0026#39;Sum\u0026#39;] \u0026gt;= 1, \u0026#34;Cold Start không được ghi lại\u0026#34; def test_memory_monitoring(self): \u0026#34;\u0026#34;\u0026#34;Kiểm thử giám sát việc sử dụng bộ nhớ\u0026#34;\u0026#34;\u0026#34; response = self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({\u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;}) ) # Kiểm tra response headers cho memory report payload = json.loads(response[\u0026#39;Payload\u0026#39;].read()) headers = payload.get(\u0026#39;headers\u0026#39;, {}) assert \u0026#39;X-Memory-Report\u0026#39; in headers, \u0026#34;Không tìm thấy memory report trong headers\u0026#34; memory_report = json.loads(headers[\u0026#39;X-Memory-Report\u0026#39;]) assert \u0026#39;checkpoints\u0026#39; in memory_report, \u0026#34;Không tìm thấy memory checkpoints\u0026#34; assert len(memory_report[\u0026#39;checkpoints\u0026#39;]) \u0026gt; 0, \u0026#34;Không có memory checkpoints được ghi lại\u0026#34; def test_concurrent_hiệu suất(self): \u0026#34;\u0026#34;\u0026#34;Kiểm thử hiệu suất dưới tải đồng thời\u0026#34;\u0026#34;\u0026#34; def invoke_function(): return self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({\u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;}) ) # Kiểm thử với 10 invocations đồng thời with ThreadPoolExecutor(max_workers=10) as executor: futures = [executor.submit(invoke_function) for _ in range(10)] responses = [future.result() for future in futures] # Tất cả invocations phải thành công for response in responses: assert response[\u0026#39;StatusCode\u0026#39;] == 200 payload = json.loads(response[\u0026#39;Payload\u0026#39;].read()) assert payload[\u0026#39;statusCode\u0026#39;] == 200 def test_x_ray_tracing(self): \u0026#34;\u0026#34;\u0026#34;Kiểm thử tích hợp X-Ray tracing\u0026#34;\u0026#34;\u0026#34; response = self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({\u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;}) ) # Kiểm tra xem trace ID có tồn tại không assert \u0026#39;X-Amzn-Trace-Id\u0026#39; in response[\u0026#39;ResponseMetadata\u0026#39;][\u0026#39;HTTPHeaders\u0026#39;] # Chờ trace được xử lý time.sleep(30) # Query X-Ray cho traces xray = boto3.client(\u0026#39;xray\u0026#39;) traces = xray.get_trace_summaries( TimeRangeType=\u0026#39;TimeRangeByStartTime\u0026#39;, StartTime=datetime.utcnow() - timedelta(minutes=5), EndTime=datetime.utcnow(), FilterExpression=f\u0026#39;service(\u0026#34;{self.function_name}\u0026#34;)\u0026#39; ) assert len(traces[\u0026#39;TraceSummaries\u0026#39;]) \u0026gt; 0, \u0026#34;Không tìm thấy X-Ray traces\u0026#34; Phân tích kết quả giám sát Sau khi triển khai giám sát toàn diện, bạn sẽ quan s á t đượ c:\nCh ỉ s ố Baseline V ớ i giám sát C ả i thi ệ n Kh ả n ă ng quan s á t Hạn chế To à n di ệ n 100% MTTR 30+ ph ú t \u0026lt;5 ph ú t 83% Độ ch í nh x á c c ả nh b á o 60% 95% 58% Th ô ng tin hiệu suất C ơ b ả n Chi tiết 400% Tiếp theo: Chiến l ượ c bộ nhớ đệm \u0026amp; Khởi độ ng tr ướ c-warmup/)\n"
},
{
	"uri": "//localhost:1313/vi/5-caching-warmup/",
	"title": "Chiến l ượ c bộ nhớ đệm &amp; Khởi độ ng tr ướ c",
	"tags": [],
	"description": "",
	"content": "Chiến lược Bộ nhớ đệm \u0026amp; Khởi động trước Tổng quan Trong phần này, bạn sẽ triển khai các chiến lược bộ nhớ đệm (bộ nhớ đệm (Bộ nhớ đệm)) n â ng cao và quy tr ì nh khởi độ ng tr ướ c (Khởi độ ng tr ướ c (Warm-up)) để t ố i thi ể u h ó a cold starts và t ố i ư u h ó a th ờ i gian ph ả n h ồ i. Ch ú ng ta sẽ đề cập đế n multi-layer bộ nhớ đệm (Bộ nhớ đệm), connection pooling, và các c ơ chếKhởi độ ng tr ướ c (Warm-up) th ô ng minh.\nKiến trúc Multi-Layer Bộ nhớ đệm (Caching) 1. Application-Level Bộ nhớ đệm (Caching) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 # src/Bộ nhớ đệm (Caching)/app_cache.py import time import json from functools import wraps from typing import Any, Optional, Dict class InMemoryCache: \u0026#34;\u0026#34;\u0026#34;Thread-safe in-memory cache với hỗ trợ TTL\u0026#34;\u0026#34;\u0026#34; def __init__(self, default_ttl: int = 300): self._cache: Dict[str, Dict] = {} self.default_ttl = default_ttl def get(self, key: str) -\u0026gt; Optional[Any]: \u0026#34;\u0026#34;\u0026#34;Lấy giá trị từ cache\u0026#34;\u0026#34;\u0026#34; if key not in self._cache: return None entry = self._cache[key] if time.time() \u0026gt; entry[\u0026#39;expires\u0026#39;]: del self._cache[key] return None entry[\u0026#39;hits\u0026#39;] += 1 entry[\u0026#39;last_accessed\u0026#39;] = time.time() return entry[\u0026#39;value\u0026#39;] def set(self, key: str, value: Any, ttl: Optional[int] = None) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Đặt giá trị vào cache\u0026#34;\u0026#34;\u0026#34; ttl = ttl or self.default_ttl self._cache[key] = { \u0026#39;value\u0026#39;: value, \u0026#39;expires\u0026#39;: time.time() + ttl, \u0026#39;created\u0026#39;: time.time(), \u0026#39;last_accessed\u0026#39;: time.time(), \u0026#39;hits\u0026#39;: 0 } def delete(self, key: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Xóa key khỏi cache\u0026#34;\u0026#34;\u0026#34; if key in self._cache: del self._cache[key] return True return False def clear(self) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34;Xóa tất cả cache entries\u0026#34;\u0026#34;\u0026#34; self._cache.clear() def stats(self) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Lấy thống kê cache\u0026#34;\u0026#34;\u0026#34; total_entries = len(self._cache) total_hits = sum(entry[\u0026#39;hits\u0026#39;] for entry in self._cache.values()) return { \u0026#39;total_entries\u0026#39;: total_entries, \u0026#39;total_hits\u0026#39;: total_hits, \u0026#39;memory_usage_mb\u0026#39;: self._estimate_memory_usage() } def _estimate_memory_usage(self) -\u0026gt; float: \u0026#34;\u0026#34;\u0026#34;Ước tính việc sử dụng bộ nhớ tính bằng MB\u0026#34;\u0026#34;\u0026#34; import sys total_size = 0 for entry in self._cache.values(): total_size += sys.getsizeof(entry[\u0026#39;value\u0026#39;]) return total_size / 1024 / 1024 # Global cache instance app_cache = InMemoryCache(default_ttl=300) def cached(ttl: int = 300, key_prefix: str = \u0026#34;\u0026#34;): \u0026#34;\u0026#34;\u0026#34;Decorator để cache kết quả function\u0026#34;\u0026#34;\u0026#34; def decorator(func): @wraps(func) def wrapper(*args, **kwargs): # Tạo cache key cache_key = f\u0026#34;{key_prefix}{func.__name__}:{hash(str(args) + str(kwargs))}\u0026#34; # Thử lấy từ cache cached_result = app_cache.get(cache_key) if cached_result is not None: return cached_result # Thực thi function và cache kết quả result = func(*args, **kwargs) app_cache.set(cache_key, result, ttl) return result return wrapper return decorator 2. Redis Distributed Bộ nhớ đệm (Caching) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 # src/Bộ nhớ đệm (Caching)/redis_cache.py import redis import json import pickle import time from typing import Any, Optional import os class RedisCache: \u0026#34;\u0026#34;\u0026#34;Redis-based distributed cache\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.redis_client = redis.Redis( host=os.environ.get(\u0026#39;REDIS_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), port=int(os.environ.get(\u0026#39;REDIS_PORT\u0026#39;, 6379)), db=int(os.environ.get(\u0026#39;REDIS_DB\u0026#39;, 0)), decode_responses=False, # Xử lý binary data socket_connect_timeout=5, socket_timeout=5, retry_on_timeout=True, health_check_interval=30 ) def get(self, key: str) -\u0026gt; Optional[Any]: \u0026#34;\u0026#34;\u0026#34;Lấy giá trị từ Redis cache\u0026#34;\u0026#34;\u0026#34; try: value = self.redis_client.get(key) if value is None: return None return pickle.loads(value) except Exception as e: print(f\u0026#34;Redis get error cho key {key}: {e}\u0026#34;) return None def set(self, key: str, value: Any, ttl: int = 300) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Đặt giá trị vào Redis cache\u0026#34;\u0026#34;\u0026#34; try: serialized_value = pickle.dumps(value) return self.redis_client.setex(key, ttl, serialized_value) except Exception as e: print(f\u0026#34;Redis set error cho key {key}: {e}\u0026#34;) return False def delete(self, key: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Xóa key khỏi Redis cache\u0026#34;\u0026#34;\u0026#34; try: return bool(self.redis_client.delete(key)) except Exception as e: print(f\u0026#34;Redis delete error cho key {key}: {e}\u0026#34;) return False def exists(self, key: str) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;Kiểm tra xem key có tồn tại trong Redis không\u0026#34;\u0026#34;\u0026#34; try: return bool(self.redis_client.exists(key)) except Exception as e: print(f\u0026#34;Redis exists error cho key {key}: {e}\u0026#34;) return False def increment(self, key: str, amount: int = 1) -\u0026gt; Optional[int]: \u0026#34;\u0026#34;\u0026#34;Tăng counter trong Redis\u0026#34;\u0026#34;\u0026#34; try: return self.redis_client.incrby(key, amount) except Exception as e: print(f\u0026#34;Redis increment error cho key {key}: {e}\u0026#34;) return None def get_stats(self) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Lấy thống kê Redis cache\u0026#34;\u0026#34;\u0026#34; try: info = self.redis_client.info() return { \u0026#39;connected_clients\u0026#39;: info.get(\u0026#39;connected_clients\u0026#39;, 0), \u0026#39;used_memory_mb\u0026#39;: info.get(\u0026#39;used_memory\u0026#39;, 0) / 1024 / 1024, \u0026#39;keyspace_hits\u0026#39;: info.get(\u0026#39;keyspace_hits\u0026#39;, 0), \u0026#39;keyspace_misses\u0026#39;: info.get(\u0026#39;keyspace_misses\u0026#39;, 0), \u0026#39;hit_rate\u0026#39;: self._calculate_hit_rate(info) } except Exception as e: print(f\u0026#34;Redis stats error: {e}\u0026#34;) return {} def _calculate_hit_rate(self, info: Dict) -\u0026gt; float: \u0026#34;\u0026#34;\u0026#34;Tính toán tỷ lệ cache hit\u0026#34;\u0026#34;\u0026#34; hits = info.get(\u0026#39;keyspace_hits\u0026#39;, 0) misses = info.get(\u0026#39;keyspace_misses\u0026#39;, 0) total = hits + misses return (hits / total * 100) if total \u0026gt; 0 else 0 # Global Redis cache instance redis_cache = RedisCache() "
},
{
	"uri": "//localhost:1313/vi/3-container-optimization/3.5-testing/",
	"title": "Kiểm thử và Quality Assurance",
	"tags": [],
	"description": "",
	"content": "Kiểm thử và Quality Assurance Tổng quan Trong phần này, chúng ta sẽ implement comprehensive Kiểm thử strategy cho Lambda container applications, bao g ồ m unit tests, integration tests, và hiệu suất tests.\nUnit Kiểm thử Setup 1. Test Dependencies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cd ~/lambda-container-workshop # Thêm test dependencies vào requirements cat \u0026gt;\u0026gt; requirements-dev.txt \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # Kiểm thử dependencies pytest==7.4.0 pytest-cov==4.1.0 pytest-mock==3.11.1 moto==4.2.0 boto3-stubs==1.34.0 # Code quality black==23.0.0 flake8==6.0.0 bandit==1.7.5 safety==2.3.0 EOF # Install development dependencies pip install -r requirements-dev.txt 2. Test Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Tạo pytest configuration cat \u0026gt; pytest.ini \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; [tool:pytest] testpaths = tests python_files = test_*.py python_classes = Test* python_functions = test_* addopts = -v --tb=short --cov=src --cov=lambda_function --cov-report=term-missing --cov-report=html:htmlcov --cov-report=xml:coverage.xml --cov-fail-under=80 markers = unit: Unit tests integration: Integration tests hiệu suất: Hiệu suất tests slow: Slow running tests EOF Unit Tests Implementation 1. Test Lambda Handler 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 mkdir -p tests/unit cat \u0026gt; tests/unit/test_lambda_handler.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import json import pytest from unittest.mock import patch, MagicMock import lambda_function class TestLambdaHandler: \u0026#34;\u0026#34;\u0026#34;Test cases for Lambda handler\u0026#34;\u0026#34;\u0026#34; def test_health_check(self): \u0026#34;\u0026#34;\u0026#34;Test health check endpoint\u0026#34;\u0026#34;\u0026#34; event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/health\u0026#39; } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 200 body = json.loads(response[\u0026#39;body\u0026#39;]) assert body[\u0026#39;status\u0026#39;] == \u0026#39;healthy\u0026#39; assert \u0026#39;timestamp\u0026#39; in body assert \u0026#39;version\u0026#39; in body def test_cors_headers(self): \u0026#34;\u0026#34;\u0026#34;Test CORS headers are present\u0026#34;\u0026#34;\u0026#34; event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/health\u0026#39; } response = lambda_function.lambda_handler(event, None) assert \u0026#39;headers\u0026#39; in response headers = response[\u0026#39;headers\u0026#39;] assert headers[\u0026#39;Access-Control-Allow-Origin\u0026#39;] == \u0026#39;*\u0026#39; assert \u0026#39;Access-Control-Allow-Methods\u0026#39; in headers assert \u0026#39;Access-Control-Allow-Headers\u0026#39; in headers def test_invalid_path(self): \u0026#34;\u0026#34;\u0026#34;Test invalid path returns 404\u0026#34;\u0026#34;\u0026#34; event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/invalid\u0026#39; } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 404 body = json.loads(response[\u0026#39;body\u0026#39;]) assert body[\u0026#39;error\u0026#39;] == \u0026#39;Not Found\u0026#39; @patch(\u0026#39;lambda_function.product_service\u0026#39;) def test_list_products(self, mock_service): \u0026#34;\u0026#34;\u0026#34;Test list products endpoint\u0026#34;\u0026#34;\u0026#34; # Mock service response mock_service.list_products.return_value = { \u0026#39;products\u0026#39;: [{\u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Test Product\u0026#39;}], \u0026#39;total\u0026#39;: 1 } event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;queryStringParameters\u0026#39;: {\u0026#39;limit\u0026#39;: \u0026#39;10\u0026#39;} } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 200 mock_service.list_products.assert_called_once_with(10, 0) @patch(\u0026#39;lambda_function.product_service\u0026#39;) def test_get_product_found(self, mock_service): \u0026#34;\u0026#34;\u0026#34;Test get single product - found\u0026#34;\u0026#34;\u0026#34; mock_service.get_product.return_value = { \u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Test Product\u0026#39; } event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products/1\u0026#39;, \u0026#39;pathParameters\u0026#39;: {\u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;} } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 200 mock_service.get_product.assert_called_once_with(\u0026#39;1\u0026#39;) @patch(\u0026#39;lambda_function.product_service\u0026#39;) def test_get_product_not_found(self, mock_service): \u0026#34;\u0026#34;\u0026#34;Test get single product - not found\u0026#34;\u0026#34;\u0026#34; mock_service.get_product.return_value = None event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products/999\u0026#39;, \u0026#39;pathParameters\u0026#39;: {\u0026#39;id\u0026#39;: \u0026#39;999\u0026#39;} } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 404 body = json.loads(response[\u0026#39;body\u0026#39;]) assert body[\u0026#39;error\u0026#39;] == \u0026#39;Product not found\u0026#39; @patch(\u0026#39;lambda_function.product_service\u0026#39;) def test_create_product(self, mock_service): \u0026#34;\u0026#34;\u0026#34;Test create product endpoint\u0026#34;\u0026#34;\u0026#34; mock_service.create_product.return_value = { \u0026#39;id\u0026#39;: \u0026#39;123\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;New Product\u0026#39;, \u0026#39;price\u0026#39;: 99.99 } event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;name\u0026#39;: \u0026#39;New Product\u0026#39;, \u0026#39;price\u0026#39;: 99.99, \u0026#39;category\u0026#39;: \u0026#39;Test\u0026#39; }) } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 201 mock_service.create_product.assert_called_once() def test_exception_handling(self): \u0026#34;\u0026#34;\u0026#34;Test exception handling returns 500\u0026#34;\u0026#34;\u0026#34; with patch(\u0026#39;lambda_function.product_service\u0026#39;) as mock_service: mock_service.list_products.side_effect = Exception(\u0026#34;Database error\u0026#34;) event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39; } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 500 body = json.loads(response[\u0026#39;body\u0026#39;]) assert body[\u0026#39;error\u0026#39;] == \u0026#39;Internal Server Error\u0026#39; EOF 2. Test Product Service 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 cat \u0026gt; tests/unit/test_product_service.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import pytest from src.api.product_service import ProductService class TestProductService: \u0026#34;\u0026#34;\u0026#34;Test cases for Product Service\u0026#34;\u0026#34;\u0026#34; def setup_method(self): \u0026#34;\u0026#34;\u0026#34;Setup test fixtures\u0026#34;\u0026#34;\u0026#34; self.service = ProductService() def test_list_products_default(self): \u0026#34;\u0026#34;\u0026#34;Test list products with default parameters\u0026#34;\u0026#34;\u0026#34; result = self.service.list_products() assert \u0026#39;products\u0026#39; in result assert \u0026#39;total\u0026#39; in result assert \u0026#39;limit\u0026#39; in result assert \u0026#39;offset\u0026#39; in result assert \u0026#39;has_more\u0026#39; in result assert result[\u0026#39;limit\u0026#39;] == 10 assert result[\u0026#39;offset\u0026#39;] == 0 assert len(result[\u0026#39;products\u0026#39;]) \u0026lt;= 10 def test_list_products_with_pagination(self): \u0026#34;\u0026#34;\u0026#34;Test list products with pagination\u0026#34;\u0026#34;\u0026#34; result = self.service.list_products(limit=2, offset=1) assert result[\u0026#39;limit\u0026#39;] == 2 assert result[\u0026#39;offset\u0026#39;] == 1 assert len(result[\u0026#39;products\u0026#39;]) \u0026lt;= 2 def test_get_product_exists(self): \u0026#34;\u0026#34;\u0026#34;Test get product that exists\u0026#34;\u0026#34;\u0026#34; product = self.service.get_product(\u0026#39;1\u0026#39;) assert product is not None assert product[\u0026#39;id\u0026#39;] == \u0026#39;1\u0026#39; assert \u0026#39;name\u0026#39; in product assert \u0026#39;price\u0026#39; in product def test_get_product_not_exists(self): \u0026#34;\u0026#34;\u0026#34;Test get product that doesn\u0026#39;t exist\u0026#34;\u0026#34;\u0026#34; product = self.service.get_product(\u0026#39;999\u0026#39;) assert product is None def test_create_product(self): \u0026#34;\u0026#34;\u0026#34;Test create new product\u0026#34;\u0026#34;\u0026#34; product_data = { \u0026#39;name\u0026#39;: \u0026#39;Test Product\u0026#39;, \u0026#39;price\u0026#39;: 99.99, \u0026#39;category\u0026#39;: \u0026#39;Test\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Test description\u0026#39; } initial_count = len(self.service.products) product = self.service.create_product(product_data) assert product is not None assert \u0026#39;id\u0026#39; in product assert product[\u0026#39;name\u0026#39;] == product_data[\u0026#39;name\u0026#39;] assert product[\u0026#39;price\u0026#39;] == product_data[\u0026#39;price\u0026#39;] assert \u0026#39;created_at\u0026#39; in product assert len(self.service.products) == initial_count + 1 def test_update_product_exists(self): \u0026#34;\u0026#34;\u0026#34;Test update existing product\u0026#34;\u0026#34;\u0026#34; update_data = { \u0026#39;name\u0026#39;: \u0026#39;Updated Product\u0026#39;, \u0026#39;price\u0026#39;: 199.99 } product = self.service.update_product(\u0026#39;1\u0026#39;, update_data) assert product is not None assert product[\u0026#39;name\u0026#39;] == update_data[\u0026#39;name\u0026#39;] assert product[\u0026#39;price\u0026#39;] == update_data[\u0026#39;price\u0026#39;] assert \u0026#39;updated_at\u0026#39; in product def test_update_product_not_exists(self): \u0026#34;\u0026#34;\u0026#34;Test update non-existing product\u0026#34;\u0026#34;\u0026#34; update_data = {\u0026#39;name\u0026#39;: \u0026#39;Updated Product\u0026#39;} product = self.service.update_product(\u0026#39;999\u0026#39;, update_data) assert product is None def test_delete_product_exists(self): \u0026#34;\u0026#34;\u0026#34;Test delete existing product\u0026#34;\u0026#34;\u0026#34; initial_count = len(self.service.products) result = self.service.delete_product(\u0026#39;1\u0026#39;) assert result is True assert len(self.service.products) == initial_count - 1 assert self.service.get_product(\u0026#39;1\u0026#39;) is None def test_delete_product_not_exists(self): \u0026#34;\u0026#34;\u0026#34;Test delete non-existing product\u0026#34;\u0026#34;\u0026#34; initial_count = len(self.service.products) result = self.service.delete_product(\u0026#39;999\u0026#39;) assert result is False assert len(self.service.products) == initial_count EOF 3. Test Hiệu suất Metrics 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 cat \u0026gt; tests/unit/test_hiệu suất_metrics.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import pytest from unittest.mock import patch, MagicMock from src.monitoring.hiệu suất_metrics import Hiệu suấtMetrics class TestHiệu suấtMetrics: \u0026#34;\u0026#34;\u0026#34;Test cases for Hiệu suất Metrics\u0026#34;\u0026#34;\u0026#34; def setup_method(self): \u0026#34;\u0026#34;\u0026#34;Setup test fixtures\u0026#34;\u0026#34;\u0026#34; with patch(\u0026#39;boto3.client\u0026#39;): self.metrics = Hiệu suấtMetrics() @patch(\u0026#39;boto3.client\u0026#39;) def test_init(self, mock_boto_client): \u0026#34;\u0026#34;\u0026#34;Test metrics initialization\u0026#34;\u0026#34;\u0026#34; metrics = Hiệu suấtMetrics() assert metrics.namespace == \u0026#39;Lambda/ContainerHiệu suất\u0026#39; mock_boto_client.assert_called_with(\u0026#39;CloudWatch\u0026#39;) def test_record_request(self): \u0026#34;\u0026#34;\u0026#34;Test record request metrics\u0026#34;\u0026#34;\u0026#34; with patch.object(self.metrics, \u0026#39;put_metric\u0026#39;) as mock_put_metric: self.metrics.record_request(\u0026#39;GET\u0026#39;, \u0026#39;/products\u0026#39;, 200, 150.5) # Should call put_metric multiple times assert mock_put_metric.call_count \u0026gt;= 2 # Check ResponseTime metric calls = mock_put_metric.call_args_list response_time_call = next( call for call in calls if call[0][0] == \u0026#39;ResponseTime\u0026#39; ) assert response_time_call[0][1] == 150.5 assert response_time_call[0][2] == \u0026#39;Milliseconds\u0026#39; def test_record_request_with_error(self): \u0026#34;\u0026#34;\u0026#34;Test record request with error status\u0026#34;\u0026#34;\u0026#34; with patch.object(self.metrics, \u0026#39;put_metric\u0026#39;) as mock_put_metric: self.metrics.record_request(\u0026#39;POST\u0026#39;, \u0026#39;/products\u0026#39;, 500, 200.0) # Should record error metric for 5xx status error_calls = [ call for call in mock_put_metric.call_args_list if call[0][0] == \u0026#39;ErrorCount\u0026#39; ] assert len(error_calls) \u0026gt; 0 def test_put_metric(self): \u0026#34;\u0026#34;\u0026#34;Test put metric to CloudWatch\u0026#34;\u0026#34;\u0026#34; with patch.object(self.metrics.CloudWatch, \u0026#39;put_metric_data\u0026#39;) as mock_put: dimensions = [{\u0026#39;Name\u0026#39;: \u0026#39;Method\u0026#39;, \u0026#39;Value\u0026#39;: \u0026#39;GET\u0026#39;}] self.metrics.put_metric(\u0026#39;TestMetric\u0026#39;, 100, \u0026#39;Count\u0026#39;, dimensions) mock_put.assert_called_once() call_args = mock_put.call_args[1] assert call_args[\u0026#39;Namespace\u0026#39;] == \u0026#39;Lambda/ContainerHiệu suất\u0026#39; assert len(call_args[\u0026#39;MetricData\u0026#39;]) == 1 metric_data = call_args[\u0026#39;MetricData\u0026#39;][0] assert metric_data[\u0026#39;MetricName\u0026#39;] == \u0026#39;TestMetric\u0026#39; assert metric_data[\u0026#39;Value\u0026#39;] == 100 assert metric_data[\u0026#39;Unit\u0026#39;] == \u0026#39;Count\u0026#39; def test_put_metric_exception_handling(self): \u0026#34;\u0026#34;\u0026#34;Test put metric handles exceptions gracefully\u0026#34;\u0026#34;\u0026#34; with patch.object(self.metrics.CloudWatch, \u0026#39;put_metric_data\u0026#39;) as mock_put: mock_put.side_effect = Exception(\u0026#34;CloudWatch error\u0026#34;) # Should not raise exception try: self.metrics.put_metric(\u0026#39;TestMetric\u0026#39;, 100, \u0026#39;Count\u0026#39;, []) except Exception: pytest.fail(\u0026#34;put_metric should handle exceptions gracefully\u0026#34;) EOF Integration Tests 1. Integration Test Setup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 mkdir -p tests/integration cat \u0026gt; tests/integration/test_lambda_integration.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import json import pytest import boto3 from moto import mock_lambda, mock_ecr, mock_iam import lambda_function @mock_lambda @mock_iam class TestLambdaIntegration: \u0026#34;\u0026#34;\u0026#34;Integration tests for Lambda function\u0026#34;\u0026#34;\u0026#34; def setup_method(self): \u0026#34;\u0026#34;\u0026#34;Setup AWS mocks\u0026#34;\u0026#34;\u0026#34; self.lambda_client = boto3.client(\u0026#39;lambda\u0026#39;, region_name=\u0026#39;us-east-1\u0026#39;) self.iam_client = boto3.client(\u0026#39;iam\u0026#39;, region_name=\u0026#39;us-east-1\u0026#39;) def test_full_request_flow(self): \u0026#34;\u0026#34;\u0026#34;Test complete request flow\u0026#34;\u0026#34;\u0026#34; # Test health check event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/health\u0026#39; } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 200 # Test list products event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39; } response = lambda_function.lambda_handler(event, None) assert response[\u0026#39;statusCode\u0026#39;] == 200 body = json.loads(response[\u0026#39;body\u0026#39;]) assert \u0026#39;products\u0026#39; in body assert \u0026#39;total\u0026#39; in body def test_crud_operations(self): \u0026#34;\u0026#34;\u0026#34;Test CRUD operations flow\u0026#34;\u0026#34;\u0026#34; # Create product create_event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;name\u0026#39;: \u0026#39;Integration Test Product\u0026#39;, \u0026#39;price\u0026#39;: 99.99, \u0026#39;category\u0026#39;: \u0026#39;Test\u0026#39; }) } response = lambda_function.lambda_handler(create_event, None) assert response[\u0026#39;statusCode\u0026#39;] == 201 created_product = json.loads(response[\u0026#39;body\u0026#39;]) product_id = created_product[\u0026#39;id\u0026#39;] # Get product get_event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: f\u0026#39;/products/{product_id}\u0026#39;, \u0026#39;pathParameters\u0026#39;: {\u0026#39;id\u0026#39;: product_id} } response = lambda_function.lambda_handler(get_event, None) assert response[\u0026#39;statusCode\u0026#39;] == 200 # Update product update_event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;PUT\u0026#39;, \u0026#39;path\u0026#39;: f\u0026#39;/products/{product_id}\u0026#39;, \u0026#39;pathParameters\u0026#39;: {\u0026#39;id\u0026#39;: product_id}, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;name\u0026#39;: \u0026#39;Updated Integration Test Product\u0026#39;, \u0026#39;price\u0026#39;: 149.99 }) } response = lambda_function.lambda_handler(update_event, None) assert response[\u0026#39;statusCode\u0026#39;] == 200 # Delete product delete_event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;DELETE\u0026#39;, \u0026#39;path\u0026#39;: f\u0026#39;/products/{product_id}\u0026#39;, \u0026#39;pathParameters\u0026#39;: {\u0026#39;id\u0026#39;: product_id} } response = lambda_function.lambda_handler(delete_event, None) assert response[\u0026#39;statusCode\u0026#39;] == 204 EOF Hiệu suất Tests 1. Hiệu suất Test Suite 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 mkdir -p tests/hiệu suất cat \u0026gt; tests/hiệu suất/test_hiệu suất.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; import time import pytest import statistics import lambda_function @pytest.mark.hiệu suất class TestHiệu suất: \u0026#34;\u0026#34;\u0026#34;Hiệu suất tests for Lambda function\u0026#34;\u0026#34;\u0026#34; def test_cold_start_simulation(self): \u0026#34;\u0026#34;\u0026#34;Test Cold Start hiệu suất\u0026#34;\u0026#34;\u0026#34; # Simulate Cold Start by creating new handler instance start_time = time.time() event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/health\u0026#39; } response = lambda_function.lambda_handler(event, None) duration = (time.time() - start_time) * 1000 # Convert to ms assert response[\u0026#39;statusCode\u0026#39;] == 200 assert duration \u0026lt; 1000 # Should be under 1 second print(f\u0026#34;Cold Start duration: {duration:.2f}ms\u0026#34;) def test_warm_invocation_hiệu suất(self): \u0026#34;\u0026#34;\u0026#34;Test warm invocation hiệu suất\u0026#34;\u0026#34;\u0026#34; durations = [] # Warm up event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39; } lambda_function.lambda_handler(event, None) # Measure warm invocations for _ in range(10): start_time = time.time() response = lambda_function.lambda_handler(event, None) duration = (time.time() - start_time) * 1000 assert response[\u0026#39;statusCode\u0026#39;] == 200 durations.append(duration) avg_duration = statistics.mean(durations) p95_duration = statistics.quantiles(durations, n=20)[18] # 95th percentile assert avg_duration \u0026lt; 100 # Average should be under 100ms assert p95_duration \u0026lt; 200 # 95th percentile under 200ms print(f\u0026#34;Warm invocation - Avg: {avg_duration:.2f}ms, P95: {p95_duration:.2f}ms\u0026#34;) def test_memory_usage(self): \u0026#34;\u0026#34;\u0026#34;Test memory usage patterns\u0026#34;\u0026#34;\u0026#34; import psutil import os process = psutil.Process(os.getpid()) initial_memory = process.memory_info().rss # Run multiple operations for i in range(100): event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;queryStringParameters\u0026#39;: {\u0026#39;limit\u0026#39;: \u0026#39;10\u0026#39;} } lambda_function.lambda_handler(event, None) final_memory = process.memory_info().rss memory_increase = final_memory - initial_memory # Memory increase should be reasonable assert memory_increase \u0026lt; 50 * 1024 * 1024 # Less than 50MB increase print(f\u0026#34;Memory increase: {memory_increase / 1024 / 1024:.2f}MB\u0026#34;) @pytest.mark.slow def test_sustained_load(self): \u0026#34;\u0026#34;\u0026#34;Test hiệu suất under sustained load\u0026#34;\u0026#34;\u0026#34; durations = [] errors = 0 event = { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39; } # Run for 30 seconds end_time = time.time() + 30 while time.time() \u0026lt; end_time: start_time = time.time() try: response = lambda_function.lambda_handler(event, None) duration = (time.time() - start_time) * 1000 durations.append(duration) if response[\u0026#39;statusCode\u0026#39;] != 200: errors += 1 except Exception: errors += 1 time.sleep(0.1) # 10 RPS total_requests = len(durations) error_rate = errors / total_requests if total_requests \u0026gt; 0 else 0 avg_duration = statistics.mean(durations) if durations else 0 assert error_rate \u0026lt; 0.01 # Less than 1% error rate assert avg_duration \u0026lt; 150 # Average under 150ms print(f\u0026#34;Sustained load - Requests: {total_requests}, \u0026#34; f\u0026#34;Error rate: {error_rate:.2%}, Avg duration: {avg_duration:.2f}ms\u0026#34;) EOF Test Execution Scripts 1. Test Runner Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 cat \u0026gt; scripts/run-tests.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash TEST_TYPE=${1:-\u0026#34;all\u0026#34;} echo \u0026#34;=== Running Tests: $TEST_TYPE ===\u0026#34; case $TEST_TYPE in \u0026#34;unit\u0026#34;) echo \u0026#34;Running unit tests...\u0026#34; python -m pytest tests/unit/ -v -m \u0026#34;not slow\u0026#34; ;; \u0026#34;integration\u0026#34;) echo \u0026#34;Running integration tests...\u0026#34; python -m pytest tests/integration/ -v ;; \u0026#34;hiệu suất\u0026#34;) echo \u0026#34;Running hiệu suất tests...\u0026#34; python -m pytest tests/hiệu suất/ -v -m \u0026#34;hiệu suất\u0026#34; ;; \u0026#34;all\u0026#34;) echo \u0026#34;Running all tests...\u0026#34; python -m pytest tests/ -v -m \u0026#34;not slow\u0026#34; ;; \u0026#34;full\u0026#34;) echo \u0026#34;Running full test suite (including slow tests)...\u0026#34; python -m pytest tests/ -v ;; *) echo \u0026#34;Usage: $0 [unit|integration|hiệu suất|all|full]\u0026#34; exit 1 ;; esac echo \u0026#34;✅ Tests completed!\u0026#34; EOF chmod +x scripts/run-tests.sh 2. Coverage Report Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 cat \u0026gt; scripts/coverage-report.sh \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; #!/bin/bash echo \u0026#34;=== Generating Coverage Report ===\u0026#34; # Run tests with coverage python -m pytest tests/ --cov=src --cov=lambda_function \\ --cov-report=html:htmlcov \\ --cov-report=xml:coverage.xml \\ --cov-report=term-missing echo \u0026#34;Coverage reports generated:\u0026#34; echo \u0026#34;- HTML: htmlcov/index.html\u0026#34; echo \u0026#34;- XML: coverage.xml\u0026#34; echo \u0026#34;- Terminal output above\u0026#34; # Check coverage threshold COVERAGE=$(python -c \u0026#34; import xml.etree.ElementTree as ET tree = ET.parse(\u0026#39;coverage.xml\u0026#39;) root = tree.getroot() print(float(root.attrib[\u0026#39;line-rate\u0026#39;]) * 100) \u0026#34;) echo \u0026#34;Current coverage: ${COVERAGE}%\u0026#34; if (( $(echo \u0026#34;$COVERAGE \u0026lt; 80\u0026#34; | bc -l) )); then echo \u0026#34;❌ Coverage below 80% threshold\u0026#34; exit 1 else echo \u0026#34;✅ Coverage meets 80% threshold\u0026#34; fi EOF chmod +x scripts/coverage-report.sh Test Data và Fixtures 1. Test Fixtures 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 mkdir -p tests/fixtures cat \u0026gt; tests/fixtures/sample_data.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026#34;\u0026#34;\u0026#34;Test fixtures and sample data\u0026#34;\u0026#34;\u0026#34; SAMPLE_PRODUCTS = [ { \u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Test Laptop\u0026#39;, \u0026#39;price\u0026#39;: 999.99, \u0026#39;category\u0026#39;: \u0026#39;Electronics\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Test laptop for unit tests\u0026#39; }, { \u0026#39;id\u0026#39;: \u0026#39;2\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Test Phone\u0026#39;, \u0026#39;price\u0026#39;: 599.99, \u0026#39;category\u0026#39;: \u0026#39;Electronics\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Test phone for unit tests\u0026#39; } ] SAMPLE_API_EVENTS = { \u0026#39;health_check\u0026#39;: { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/health\u0026#39; }, \u0026#39;list_products\u0026#39;: { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;queryStringParameters\u0026#39;: {\u0026#39;limit\u0026#39;: \u0026#39;10\u0026#39;} }, \u0026#39;get_product\u0026#39;: { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products/1\u0026#39;, \u0026#39;pathParameters\u0026#39;: {\u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;} }, \u0026#39;create_product\u0026#39;: { \u0026#39;httpMethod\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;body\u0026#39;: \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;New Product\u0026#34;,\u0026#34;price\u0026#34;:99.99,\u0026#34;category\u0026#34;:\u0026#34;Test\u0026#34;}\u0026#39; } } EOF cat \u0026gt; tests/conftest.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026#34;\u0026#34;\u0026#34;Pytest configuration and fixtures\u0026#34;\u0026#34;\u0026#34; import pytest import os import sys # Add src to Python path sys.path.insert(0, os.path.join(os.path.dirname(__file__), \u0026#39;..\u0026#39;, \u0026#39;src\u0026#39;)) @pytest.fixture def sample_event(): \u0026#34;\u0026#34;\u0026#34;Sample API Gateway event\u0026#34;\u0026#34;\u0026#34; return { \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/health\u0026#39;, \u0026#39;headers\u0026#39;: {}, \u0026#39;queryStringParameters\u0026#39;: None, \u0026#39;pathParameters\u0026#39;: None, \u0026#39;body\u0026#39;: None } @pytest.fixture def lambda_context(): \u0026#34;\u0026#34;\u0026#34;Mock Lambda context\u0026#34;\u0026#34;\u0026#34; class MockContext: def __init__(self): self.function_name = \u0026#39;test-function\u0026#39; self.function_version = \u0026#39;1\u0026#39; self.invoked_function_arn = \u0026#39;arn:aws:lambda:us-east-1:123456789012:function:test-function\u0026#39; self.memory_limit_in_mb = 512 self.remaining_time_in_millis = lambda: 30000 self.log_group_name = \u0026#39;/aws/lambda/test-function\u0026#39; self.log_stream_name = \u0026#39;2023/01/01/[$LATEST]test\u0026#39; self.aws_request_id = \u0026#39;test-request-id\u0026#39; return MockContext() EOF Kết luận Bạn đã implement comprehensive Kiểm thử strategy:\n✅ Unit tests cho t ấ t c ả components ✅ Integration tests cho end-to-end flows ✅ Hi ệ u su ấ t tests và Đá nh gi á hiệu suất (Benchmarking) ✅ Code coverage reporting (80% threshold) ✅ Test fixtures và sample data ✅ Automated test execution scripts ✅ CI/CD integration ready Kiểm thử Thực hành tốt nhất Implemented:\nComprehensive test coverage (unit, integration, hiệu suất) Mocking external dependencies Hi ệ u su ấ t Đá nh gi á hiệu suất (Benchmarking) Automated test execution Coverage reporting and thresholds Quy trình CI/CD (CI/CD Pipeline) integration Kiểm thử framework này đả m b ả o code quality và reliability cho Lambda container applications.\n"
},
{
	"uri": "//localhost:1313/vi/6-cost-analysis/",
	"title": "Ph â n t í ch chi ph í &amp; Đá nh gi á hiệu suất",
	"tags": [],
	"description": "",
	"content": "Phân tích chi phí \u0026amp; Đánh giá hiệu suất Tổng quan Trong phần này, Bạn sẽ học để phân tích và tối ưu hóa the costs of your Lambda container functions. We\u0026rsquo;ll implement cost giám sát (Giám sát), perform detailed Đá nh gi á hiệu suất (Đánh giá hiệu suất), and establish cost tối ưu hóa strategies.\nCost Giám sáting Triển khaiation 1. Cost Tracking Lambda Function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 # src/cost_analysis/cost_tracker.py import boto3 import json from datetime import datetime, timedelta from typing import Dict, List import os class LambdaCostTracker: \u0026#34;\u0026#34;\u0026#34;Track and analyze Lambda function costs\u0026#34;\u0026#34;\u0026#34; def __init__(self): self.ce_client = boto3.client(\u0026#39;ce\u0026#39;) # Cost Explorer self.lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) self.CloudWatch = boto3.client(\u0026#39;CloudWatch\u0026#39;) def get_lambda_costs(self, function_name: str, days: int = 30) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Get Lambda function costs for specified period\u0026#34;\u0026#34;\u0026#34; end_date = datetime.utcnow().date() start_date = end_date - timedelta(days=days) try: response = self.ce_client.get_cost_and_usage( TimePeriod={ \u0026#39;Start\u0026#39;: start_date.strftime(\u0026#39;%Y-%m-%d\u0026#39;), \u0026#39;End\u0026#39;: end_date.strftime(\u0026#39;%Y-%m-%d\u0026#39;) }, Granularity=\u0026#39;DAILY\u0026#39;, Metrics=[\u0026#39;BlendedCost\u0026#39;, \u0026#39;UsageQuantity\u0026#39;], GroupBy=[ {\u0026#39;Type\u0026#39;: \u0026#39;DIMENSION\u0026#39;, \u0026#39;Key\u0026#39;: \u0026#39;SERVICE\u0026#39;}, {\u0026#39;Type\u0026#39;: \u0026#39;DIMENSION\u0026#39;, \u0026#39;Key\u0026#39;: \u0026#39;USAGE_TYPE\u0026#39;} ], Filter={ \u0026#39;Dimensions\u0026#39;: { \u0026#39;Key\u0026#39;: \u0026#39;SERVICE\u0026#39;, \u0026#39;Values\u0026#39;: [\u0026#39;AWS Lambda\u0026#39;] } } ) return self._process_cost_data(response, function_name) except Exception as e: print(f\u0026#34;Error getting cost data: {e}\u0026#34;) return {} def _process_cost_data(self, cost_response: Dict, function_name: str) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Process cost explorer response\u0026#34;\u0026#34;\u0026#34; total_cost = 0 daily_costs = [] usage_breakdown = {} for result in cost_response[\u0026#39;ResultsByTime\u0026#39;]: date = result[\u0026#39;TimePeriod\u0026#39;][\u0026#39;Start\u0026#39;] daily_cost = 0 for group in result[\u0026#39;Groups\u0026#39;]: service = group[\u0026#39;Keys\u0026#39;][0] usage_type = group[\u0026#39;Keys\u0026#39;][1] cost = float(group[\u0026#39;Metrics\u0026#39;][\u0026#39;BlendedCost\u0026#39;][\u0026#39;Amount\u0026#39;]) usage = float(group[\u0026#39;Metrics\u0026#39;][\u0026#39;UsageQuantity\u0026#39;][\u0026#39;Amount\u0026#39;]) if service == \u0026#39;AWS Lambda\u0026#39;: daily_cost += cost if usage_type not in usage_breakdown: usage_breakdown[usage_type] = {\u0026#39;cost\u0026#39;: 0, \u0026#39;usage\u0026#39;: 0} usage_breakdown[usage_type][\u0026#39;cost\u0026#39;] += cost usage_breakdown[usage_type][\u0026#39;usage\u0026#39;] += usage daily_costs.append({\u0026#39;date\u0026#39;: date, \u0026#39;cost\u0026#39;: daily_cost}) total_cost += daily_cost return { \u0026#39;function_name\u0026#39;: function_name, \u0026#39;total_cost\u0026#39;: total_cost, \u0026#39;daily_costs\u0026#39;: daily_costs, \u0026#39;usage_breakdown\u0026#39;: usage_breakdown, \u0026#39;average_daily_cost\u0026#39;: total_cost / len(daily_costs) if daily_costs else 0 } def calculate_cost_per_invocation(self, function_name: str, days: int = 30) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Calculate cost per invocation\u0026#34;\u0026#34;\u0026#34; # Get cost data cost_data = self.get_lambda_costs(function_name, days) # Get invocation count end_time = datetime.utcnow() start_time = end_time - timedelta(days=days) invocation_response = self.CloudWatch.get_metric_statistics( Namespace=\u0026#39;AWS/Lambda\u0026#39;, MetricName=\u0026#39;Invocations\u0026#39;, Dimensions=[{\u0026#39;Name\u0026#39;: \u0026#39;FunctionName\u0026#39;, \u0026#39;Value\u0026#39;: function_name}], StartTime=start_time, EndTime=end_time, Period=86400, # Daily Statistics=[\u0026#39;Sum\u0026#39;] ) total_invocations = sum(point[\u0026#39;Sum\u0026#39;] for point in invocation_response[\u0026#39;Datapoints\u0026#39;]) cost_per_invocation = cost_data[\u0026#39;total_cost\u0026#39;] / total_invocations if total_invocations \u0026gt; 0 else 0 return { \u0026#39;function_name\u0026#39;: function_name, \u0026#39;period_days\u0026#39;: days, \u0026#39;total_cost\u0026#39;: cost_data[\u0026#39;total_cost\u0026#39;], \u0026#39;total_invocations\u0026#39;: total_invocations, \u0026#39;cost_per_invocation\u0026#39;: cost_per_invocation, \u0026#39;cost_per_million_invocations\u0026#39;: cost_per_invocation * 1000000 } def analyze_memory_cost_efficiency(self, function_name: str) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Phân tích memory allocation cost efficiency\u0026#34;\u0026#34;\u0026#34; # Get function configuration function_config = self.lambda_client.get_function_configuration( FunctionName=function_name ) allocated_memory = function_config[\u0026#39;MemorySize\u0026#39;] # Get actual memory usage from CloudWatch end_time = datetime.utcnow() start_time = end_time - timedelta(days=7) # Get custom memory usage metrics if available memory_response = self.CloudWatch.get_metric_statistics( Namespace=\u0026#39;Lambda/ContainerHiệu suất\u0026#39;, MetricName=\u0026#39;MemoryUsageMB\u0026#39;, Dimensions=[{\u0026#39;Name\u0026#39;: \u0026#39;FunctionName\u0026#39;, \u0026#39;Value\u0026#39;: function_name}], StartTime=start_time, EndTime=end_time, Period=3600, Statistics=[\u0026#39;Average\u0026#39;] ) if memory_response[\u0026#39;Datapoints\u0026#39;]: avg_memory_used = sum(point[\u0026#39;Average\u0026#39;] for point in memory_response[\u0026#39;Datapoints\u0026#39;]) / len(memory_response[\u0026#39;Datapoints\u0026#39;]) memory_efficiency = (avg_memory_used / allocated_memory) * 100 # Calculate potential savings optimal_memory = int(avg_memory_used * 1.2) # 20% buffer optimal_memory = max(128, min(optimal_memory, 10240)) # Lambda limits # Estimate cost savings (memory cost is proportional to allocation) current_cost_factor = allocated_memory / 128 optimal_cost_factor = optimal_memory / 128 potential_savings_percent = ((current_cost_factor - optimal_cost_factor) / current_cost_factor) * 100 return { \u0026#39;function_name\u0026#39;: function_name, \u0026#39;allocated_memory_mb\u0026#39;: allocated_memory, \u0026#39;average_used_memory_mb\u0026#39;: avg_memory_used, \u0026#39;memory_efficiency_percent\u0026#39;: memory_efficiency, \u0026#39;recommended_memory_mb\u0026#39;: optimal_memory, \u0026#39;potential_cost_savings_percent\u0026#39;: potential_savings_percent } return {\u0026#39;error\u0026#39;: \u0026#39;No memory usage data available\u0026#39;} # Cost tracking handler def cost_analysis_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Lambda handler for Phân tích chi phí\u0026#34;\u0026#34;\u0026#34; tracker = LambdaCostTracker() function_name = event.get(\u0026#39;function_name\u0026#39;, \u0026#39;workshop-product-api\u0026#39;) try: # Perform Phân tích chi phí cost_data = tracker.get_lambda_costs(function_name) cost_per_invocation = tracker.calculate_cost_per_invocation(function_name) memory_efficiency = tracker.analyze_memory_cost_efficiency(function_name) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps({ \u0026#39;cost_analysis\u0026#39;: cost_data, \u0026#39;cost_per_invocation\u0026#39;: cost_per_invocation, \u0026#39;memory_efficiency\u0026#39;: memory_efficiency }, default=str) } except Exception as e: return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;error\u0026#39;: str(e)}) } 2. Hiệu suất Đánh giá hiệu suất (Benchmarking) Suite 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 # tests/benchmark_hiệu suất.py import boto3 import json import time import statistics import concurrent.futures from datetime import datetime from typing import List, Dict class Hiệu suấtBenchmark: \u0026#34;\u0026#34;\u0026#34;Comprehensive hiệu suất Đánh giá hiệu suất (Benchmarking) suite\u0026#34;\u0026#34;\u0026#34; def __init__(self, function_name: str): self.function_name = function_name self.lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) self.results = [] def benchmark_cold_start(self, iterations: int = 10) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Benchmark Cold Start hiệu suất\u0026#34;\u0026#34;\u0026#34; cold_start_times = [] for i in range(iterations): # Force Cold Start by updating environment self.lambda_client.update_function_configuration( FunctionName=self.function_name, Environment={ \u0026#39;Variables\u0026#39;: { \u0026#39;FORCE_COLD_START\u0026#39;: str(time.time()) } } ) # Wait for update to complete time.sleep(5) # Measure invocation time start_time = time.time() response = self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({ \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;benchmark\u0026#39;: True }) ) end_time = time.time() duration_ms = (end_time - start_time) * 1000 cold_start_times.append(duration_ms) print(f\u0026#34;Cold Start {i+1}: {duration_ms:.2f}ms\u0026#34;) return { \u0026#39;test_type\u0026#39;: \u0026#39;cold_start\u0026#39;, \u0026#39;iterations\u0026#39;: iterations, \u0026#39;times_ms\u0026#39;: cold_start_times, \u0026#39;average_ms\u0026#39;: statistics.mean(cold_start_times), \u0026#39;median_ms\u0026#39;: statistics.median(cold_start_times), \u0026#39;min_ms\u0026#39;: min(cold_start_times), \u0026#39;max_ms\u0026#39;: max(cold_start_times), \u0026#39;std_dev_ms\u0026#39;: statistics.stdev(cold_start_times) if len(cold_start_times) \u0026gt; 1 else 0 } def benchmark_warm_execution(self, iterations: int = 50) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Benchmark warm execution hiệu suất\u0026#34;\u0026#34;\u0026#34; warm_times = [] # First invocation to warm up self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({\u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;}) ) time.sleep(2) # Ensure warm state for i in range(iterations): start_time = time.time() response = self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({ \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;benchmark\u0026#39;: True }) ) end_time = time.time() duration_ms = (end_time - start_time) * 1000 warm_times.append(duration_ms) # Small delay to avoid throttling time.sleep(0.1) return { \u0026#39;test_type\u0026#39;: \u0026#39;warm_execution\u0026#39;, \u0026#39;iterations\u0026#39;: iterations, \u0026#39;times_ms\u0026#39;: warm_times, \u0026#39;average_ms\u0026#39;: statistics.mean(warm_times), \u0026#39;median_ms\u0026#39;: statistics.median(warm_times), \u0026#39;min_ms\u0026#39;: min(warm_times), \u0026#39;max_ms\u0026#39;: max(warm_times), \u0026#39;std_dev_ms\u0026#39;: statistics.stdev(warm_times) if len(warm_times) \u0026gt; 1 else 0 } def benchmark_concurrent_execution(self, concurrency: int = 10, iterations: int = 5) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Benchmark concurrent execution hiệu suất\u0026#34;\u0026#34;\u0026#34; concurrent_results = [] for iteration in range(iterations): def invoke_function(): start_time = time.time() response = self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps({ \u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;benchmark\u0026#39;: True }) ) end_time = time.time() return (end_time - start_time) * 1000 # Execute concurrent invocations with concurrent.futures.ThreadPoolExecutor(max_workers=concurrency) as executor: futures = [executor.submit(invoke_function) for _ in range(concurrency)] iteration_times = [future.result() for future in futures] concurrent_results.extend(iteration_times) print(f\u0026#34;Concurrent iteration {iteration + 1}: avg {statistics.mean(iteration_times):.2f}ms\u0026#34;) return { \u0026#39;test_type\u0026#39;: \u0026#39;concurrent_execution\u0026#39;, \u0026#39;concurrency\u0026#39;: concurrency, \u0026#39;iterations\u0026#39;: iterations, \u0026#39;total_invocations\u0026#39;: len(concurrent_results), \u0026#39;times_ms\u0026#39;: concurrent_results, \u0026#39;average_ms\u0026#39;: statistics.mean(concurrent_results), \u0026#39;median_ms\u0026#39;: statistics.median(concurrent_results), \u0026#39;min_ms\u0026#39;: min(concurrent_results), \u0026#39;max_ms\u0026#39;: max(concurrent_results), \u0026#39;std_dev_ms\u0026#39;: statistics.stdev(concurrent_results) if len(concurrent_results) \u0026gt; 1 else 0 } def benchmark_memory_usage(self, test_payloads: List[Dict]) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Benchmark memory usage with different payloads\u0026#34;\u0026#34;\u0026#34; memory_results = [] for i, payload in enumerate(test_payloads): response = self.lambda_client.invoke( FunctionName=self.function_name, Payload=json.dumps(payload) ) # Parse response to get memory report response_payload = json.loads(response[\u0026#39;Payload\u0026#39;].read()) headers = response_payload.get(\u0026#39;headers\u0026#39;, {}) if \u0026#39;X-Memory-Report\u0026#39; in headers: memory_report = json.loads(headers[\u0026#39;X-Memory-Report\u0026#39;]) peak_memory = memory_report.get(\u0026#39;peak_memory_mb\u0026#39;, 0) memory_results.append({ \u0026#39;payload_size\u0026#39;: len(json.dumps(payload)), \u0026#39;peak_memory_mb\u0026#39;: peak_memory, \u0026#39;payload_type\u0026#39;: payload.get(\u0026#39;test_type\u0026#39;, f\u0026#39;test_{i}\u0026#39;) }) return { \u0026#39;test_type\u0026#39;: \u0026#39;memory_usage\u0026#39;, \u0026#39;results\u0026#39;: memory_results, \u0026#39;average_memory_mb\u0026#39;: statistics.mean([r[\u0026#39;peak_memory_mb\u0026#39;] for r in memory_results]), \u0026#39;max_memory_mb\u0026#39;: max([r[\u0026#39;peak_memory_mb\u0026#39;] for r in memory_results]), \u0026#39;min_memory_mb\u0026#39;: min([r[\u0026#39;peak_memory_mb\u0026#39;] for r in memory_results]) } def run_comprehensive_benchmark(self) -\u0026gt; Dict: \u0026#34;\u0026#34;\u0026#34;Run comprehensive benchmark suite\u0026#34;\u0026#34;\u0026#34; print(f\u0026#34;Starting comprehensive benchmark for {self.function_name}\u0026#34;) results = { \u0026#39;function_name\u0026#39;: self.function_name, \u0026#39;timestamp\u0026#39;: datetime.utcnow().isoformat(), \u0026#39;benchmarks\u0026#39;: {} } # Cold Start benchmark print(\u0026#34;Running Cold Start benchmark...\u0026#34;) results[\u0026#39;benchmarks\u0026#39;][\u0026#39;cold_start\u0026#39;] = self.benchmark_cold_start() # Warm execution benchmark print(\u0026#34;Running warm execution benchmark...\u0026#34;) results[\u0026#39;benchmarks\u0026#39;][\u0026#39;warm_execution\u0026#39;] = self.benchmark_warm_execution() # Concurrent execution benchmark print(\u0026#34;Running concurrent execution benchmark...\u0026#34;) results[\u0026#39;benchmarks\u0026#39;][\u0026#39;concurrent_execution\u0026#39;] = self.benchmark_concurrent_execution() # Memory usage benchmark print(\u0026#34;Running memory usage benchmark...\u0026#34;) test_payloads = [ {\u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;test_type\u0026#39;: \u0026#39;simple_get\u0026#39;}, {\u0026#39;httpMethod\u0026#39;: \u0026#39;POST\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;body\u0026#39;: json.dumps({\u0026#39;name\u0026#39;: \u0026#39;Kiểm thử Product\u0026#39;, \u0026#39;price\u0026#39;: 99.99}), \u0026#39;test_type\u0026#39;: \u0026#39;simple_post\u0026#39;}, {\u0026#39;httpMethod\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;path\u0026#39;: \u0026#39;/products\u0026#39;, \u0026#39;queryStringParameters\u0026#39;: {\u0026#39;limit\u0026#39;: \u0026#39;100\u0026#39;}, \u0026#39;test_type\u0026#39;: \u0026#39;large_query\u0026#39;} ] results[\u0026#39;benchmarks\u0026#39;][\u0026#39;memory_usage\u0026#39;] = self.benchmark_memory_usage(test_payloads) return results # Benchmark execution script def run_benchmark(): \u0026#34;\u0026#34;\u0026#34;Run benchmark and save results\u0026#34;\u0026#34;\u0026#34; function_name = \u0026#39;workshop-product-api\u0026#39; benchmark = Hiệu suấtBenchmark(function_name) results = benchmark.run_comprehensive_benchmark() # Save results to file timestamp = datetime.utcnow().strftime(\u0026#39;%Y%m%d_%H%M%S\u0026#39;) filename = f\u0026#39;benchmark_results_{timestamp}.json\u0026#39; with open(filename, \u0026#39;w\u0026#39;) as f: json.dump(results, f, indent=2) print(f\u0026#34;Benchmark results saved to {filename}\u0026#34;) # Print summary print(\u0026#34;\\n=== BENCHMARK SUMMARY ===\u0026#34;) for test_name, test_results in results[\u0026#39;benchmarks\u0026#39;].items(): print(f\u0026#34;\\n{test_name.upper()}:\u0026#34;) print(f\u0026#34; Average: {test_results.get(\u0026#39;average_ms\u0026#39;, 0):.2f}ms\u0026#34;) print(f\u0026#34; Median: {test_results.get(\u0026#39;median_ms\u0026#39;, 0):.2f}ms\u0026#34;) print(f\u0026#34; Min: {test_results.get(\u0026#39;min_ms\u0026#39;, 0):.2f}ms\u0026#34;) print(f\u0026#34; Max: {test_results.get(\u0026#39;max_ms\u0026#39;, 0):.2f}ms\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: run_benchmark() Next: [Tri ể n khai môi trường sản xuất](../7-M ô i tr ườ ng sản xuất/)\n"
},
{
	"uri": "//localhost:1313/vi/7-production/",
	"title": "Tri ể n khai môi trường sản xuất",
	"tags": [],
	"description": "",
	"content": "Triển khai môi trường sản xuất Tổng quan Trong phần này, bạn sẽ triển khai các tối ưu hóa của bạn Lambda container functions to M ô i tr ườ ng sản xuất using Thực hành tốt nhất for reliability, Bảo mật, and hiệu suất. We\u0026rsquo;ll implement automated CI/CD pipelines, blue-green Tri ể n khai strategies, and comprehensive giám sát (Giám sát).\nNhững gì bạn sẽ học Quy trình CI/CD (CI/CD Pipeline): Automated build, test, and Tri ể n khai with GitHub Actions Blue-Green Tri ể n khaiment: Safe M ô i tr ườ ng sản xuất deployments with gradual traffic shifting giám sát \u0026amp; Alerting: M ô i tr ườ ng sản xuất-ready giám sát (Monitoring) and automated rollback Bảo mật Integration: Bảo mật scanning and compliance checks in pipeline Hiệu suất Kiểm thử ing: Automated hiệu suất validation after deployments Các phần thực hành 7.1 Quy trình CI/CD (CI/CD Pipeline) Thiết lập Complete CI/CD implementation including:\nGitHub Actions workflows for automated Tri ể n khai Multi-environment setup (staging/M ô i tr ườ ng sản xuất) Bảo mật scanning and quality gates Blue-green Tri ể n khai with traffic shifting Automated rollback procedures Hi ệ u su ấ t Kiểm thử integration Blue-Green Triển khaiment Strategy 1. Triển khaiment Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #!/bin/bash # scripts/blue-green-deploy.sh set -e FUNCTION_NAME=${1:-workshop-product-api} NEW_IMAGE_URI=${2} TRAFFIC_SHIFT_PERCENTAGE=${3:-10} if [ -z \u0026#34;$NEW_IMAGE_URI\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;function-name\u0026gt; \u0026lt;image-uri\u0026gt; [traffic-percentage]\u0026#34; exit 1 fi echo \u0026#34;Starting blue-green Triển khai for $FUNCTION_NAME\u0026#34; # Step 1: Update function code with new image echo \u0026#34;Updating function code...\u0026#34; NEW_VERSION=$(AWS Lambda update-function-code \\ --function-name $FUNCTION_NAME \\ --image-uri $NEW_IMAGE_URI \\ --query \u0026#39;Version\u0026#39; --output text) echo \u0026#34;New version created: $NEW_VERSION\u0026#34; # Step 2: Run smoke tests echo \u0026#34;Running smoke tests...\u0026#34; ./scripts/smoke-test.sh $FUNCTION_NAME $NEW_VERSION # Step 3: Gradual traffic shift echo \u0026#34;Shifting $TRAFFIC_SHIFT_PERCENTAGE% traffic to new version...\u0026#34; AWS Lambda update-alias \\ --function-name $FUNCTION_NAME \\ --name PROD \\ --routing-config \u0026#34;AdditionalVersionWeights={\\\u0026#34;$NEW_VERSION\\\u0026#34;:$(echo \u0026#34;scale=2; $TRAFFIC_SHIFT_PERCENTAGE/100\u0026#34; | bc)}\u0026#34; echo \u0026#34;Triển khaiment completed successfully!\u0026#34; 2. Smoke Kiểm thử Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/bin/bash # scripts/smoke-test.sh FUNCTION_NAME=$1 VERSION=$2 echo \u0026#34;Running smoke tests for $FUNCTION_NAME:$VERSION\u0026#34; # Kiểm thử basic functionality RESPONSE=$(AWS Lambda invoke \\ --function-name $FUNCTION_NAME:$VERSION \\ --payload \u0026#39;{\u0026#34;httpMethod\u0026#34;:\u0026#34;GET\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;/health\u0026#34;}\u0026#39; \\ response.json) STATUS_CODE=$(echo $RESPONSE | jq -r \u0026#39;.StatusCode\u0026#39;) if [ \u0026#34;$STATUS_CODE\u0026#34; != \u0026#34;200\u0026#34; ]; then echo \u0026#34;Smoke test failed: Status code $STATUS_CODE\u0026#34; exit 1 fi echo \u0026#34;Smoke tests passed!\u0026#34; Giám sáting and Alerting Thiết lập 1. Môi trường sản xuất Alarms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/bash # scripts/setup-Môi trường sản xuất-alarms.sh FUNCTION_NAME=\u0026#34;workshop-product-api\u0026#34; SNS_TOPIC=\u0026#34;arn:aws:sns:${AWS_REGION}:${AWS_ACCOUNT_ID}:Môi trường sản xuất-alerts\u0026#34; # Error Rate Alarm aws CloudWatch put-metric-alarm \\ --alarm-name \u0026#34;PROD-${FUNCTION_NAME}-ErrorRate\u0026#34; \\ --alarm-description \u0026#34;Môi trường sản xuất error rate too high\u0026#34; \\ --metric-name Errors \\ --namespace AWS/Lambda \\ --statistic Sum \\ --period 300 \\ --threshold 5 \\ --comparison-operator GreaterThanThreshold \\ --evaluation-periods 2 \\ --alarm-actions $SNS_TOPIC \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME # Duration Alarm aws CloudWatch put-metric-alarm \\ --alarm-name \u0026#34;PROD-${FUNCTION_NAME}-Duration\u0026#34; \\ --alarm-description \u0026#34;Môi trường sản xuất duration too high\u0026#34; \\ --metric-name Duration \\ --namespace AWS/Lambda \\ --statistic Average \\ --period 300 \\ --threshold 5000 \\ --comparison-operator GreaterThanThreshold \\ --evaluation-periods 2 \\ --alarm-actions $SNS_TOPIC \\ --dimensions Name=FunctionName,Value=$FUNCTION_NAME echo \u0026#34;Môi trường sản xuất alarms configured!\u0026#34; Rollback Procedures 1. Automated Rollback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # src/Triển khai/rollback.py import boto3 import json def rollback_deployment(function_name: str, reason: str = \u0026#34;Hiệu suất degradation\u0026#34;): \u0026#34;\u0026#34;\u0026#34;Automated rollback to previous version\u0026#34;\u0026#34;\u0026#34; lambda_client = boto3.client(\u0026#39;lambda\u0026#39;) try: # Get current alias configuration alias_config = lambda_client.get_alias( FunctionName=function_name, Name=\u0026#39;PROD\u0026#39; ) current_version = alias_config[\u0026#39;FunctionVersion\u0026#39;] # Get previous version from versions list versions = lambda_client.list_versions_by_function( FunctionName=function_name ) # Find previous version version_numbers = [int(v[\u0026#39;Version\u0026#39;]) for v in versions[\u0026#39;Versions\u0026#39;] if v[\u0026#39;Version\u0026#39;] != \u0026#39;$LATEST\u0026#39;] version_numbers.sort(reverse=True) if len(version_numbers) \u0026lt; 2: raise Exception(\u0026#34;No previous version available for rollback\u0026#34;) previous_version = str(version_numbers[1]) # Update alias to point to previous version lambda_client.update_alias( FunctionName=function_name, Name=\u0026#39;PROD\u0026#39;, FunctionVersion=previous_version, Description=f\u0026#34;Rollback from {current_version} - {reason}\u0026#34; ) print(f\u0026#34;Rollback completed: {current_version} -\u0026gt; {previous_version}\u0026#34;) return True except Exception as e: print(f\u0026#34;Rollback failed: {e}\u0026#34;) return False Next: D ọ n d ẹ p t à i nguy ê n\n"
},
{
	"uri": "//localhost:1313/vi/8-cleanup/",
	"title": "D ọ n d ẹ p t à i nguy ê n",
	"tags": [],
	"description": "",
	"content": "Dọn dẹp tài nguyên Tổng quan In this final section, you\u0026rsquo;ll D ọ n d ẹ p all the AWS resources created during the workshop to avoid ongoing charges.\nCleanup Script 1. Automated Cleanup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #!/bin/bash # scripts/cleanup-workshop.sh set -e echo \u0026#34;Starting workshop cleanup...\u0026#34; # Variables FUNCTION_PREFIX=\u0026#34;workshop\u0026#34; ECR_REPOSITORY=\u0026#34;lambda-container-workshop\u0026#34; DYNAMODB_TABLE=\u0026#34;products\u0026#34; # Delete Lambda functions echo \u0026#34;Deleting Lambda functions...\u0026#34; for FUNCTION in $(AWS Lambda list-functions --query \u0026#34;Functions[?starts_with(FunctionName, \u0026#39;$FUNCTION_PREFIX\u0026#39;)].FunctionName\u0026#34; --output text); do echo \u0026#34;Deleting function: $FUNCTION\u0026#34; AWS Lambda delete-function --function-name $FUNCTION done # Delete ECR repository echo \u0026#34;Deleting ECR repository...\u0026#34; aws ecr delete-repository --repository-name $ECR_REPOSITORY --force || true # Delete CloudWatch alarms echo \u0026#34;Deleting CloudWatch alarms...\u0026#34; for ALARM in $(aws CloudWatch describe-alarms --alarm-name-prefix \u0026#34;PROD-$FUNCTION_PREFIX\u0026#34; --query \u0026#34;MetricAlarms[].AlarmName\u0026#34; --output text); do echo \u0026#34;Deleting alarm: $ALARM\u0026#34; aws CloudWatch delete-alarms --alarm-names $ALARM done # Delete CloudWatch dashboard echo \u0026#34;Deleting CloudWatch dashboard...\u0026#34; aws CloudWatch delete-dashboards --dashboard-names \u0026#34;Lambda-Container-Hiệu suất\u0026#34; || true # Delete DynamoDB table echo \u0026#34;Deleting DynamoDB table...\u0026#34; aws DynamoDB delete-table --table-name $DYNAMODB_TABLE || true # Delete IAM roles echo \u0026#34;Deleting IAM roles...\u0026#34; aws iam delete-role --role-name lambda-execution-role || true echo \u0026#34;Cleanup completed!\u0026#34; 2. Manual Cleanup Checklist Lambda functions deleted ECR repository deleted CloudWatch alarms deleted CloudWatch dashboard deleted DynamoDB tables deleted IAM roles deleted SNS topics deleted EventBridge rules deleted Cost Verification After cleanup, verify no ongoing charges:\n1 2 3 4 5 # Check for remaining Lambda functions AWS Lambda list-functions --query \u0026#34;Functions[?starts_with(FunctionName, \u0026#39;workshop\u0026#39;)]\u0026#34; # Check ECR repositories aws ecr describe-repositories --query \u0026#34;repositories[?repositoryName==\u0026#39;lambda-container-workshop\u0026#39;]\u0026#34; Workshop Summary Congratulations! You\u0026rsquo;ve completed the AWS Lambda Container Images T ố i ư u h ó a hiệu suất (Hiệu suất Optimization) workshop.\nKey Achievements ✅ T ố i ư u h ó ad Container Images for \u0026lt;1s cold starts ✅ Tri ể n khaied comprehensive giám sát (Monitoring) ✅ Applied advanced bộ nhớ đệm (Caching) strategies ✅ Conducted hiệu suất Đá nh gi á hiệu suất (Benchmarking) ✅ Tri ể n khaied with M ô i tr ườ ng sản xuất Thực hành tốt nhất Hiệu suất Improvements Achieved Metric Before After Improvement Cold Start 3-5s \u0026lt;1s 70-80% Memory Efficiency 40-60% 80-90% 50% Response Time 1.5-2s \u0026lt;500ms 70% Cost Baseline -45% 45% savings Các bước tiếp theo Apply these techniques to your M ô i tr ườ ng sản xuất workloads Explore advanced Lambda features like Extensions Consider Lambda SnapStart for Java applications Tri ể n khai automated hiệu suất Kiểm thử in CI/CD Thank you for completing Workshop này!\n"
},
{
	"uri": "//localhost:1313/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]